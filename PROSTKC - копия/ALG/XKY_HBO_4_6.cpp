/***************************************************************************

                                XKY_HBO_4_6.c
                             -------------------
 
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdarg.h>
#include <math.h>
#include "SYSCONST.h"
#include "coil.h"
#include "XKY_HBO_5_0.h"
#include "XKY_HBO_4_0.h"
#include "XKY_HBO_4_1.h"
#include "XKY_HBO_4_2.h"
#include "XKY_HBO_4_6.h"

//double TKOC[300];
//double MKC[56];

extern double TKOC[200];
extern double MKC[35];

/*------------------------------------------------------------
|                       FAARM                                |
|     Расчет   фундаментальных астрономических аргументов    |
|            ( фундаментальные аргументы отнесены            |
|              к среднему равноденствию даты (J2000) )       |
|                                                            |
|     Вход : MJD                                             |
|            MJD     - модифицированная юлианская дата       |
|                      зпохи измерений                       |
|                                                            |
|     Выход: L_b, L, L_1, F_b, D_b                           |
|            L_b     - средняя долгота Луны на дату          |
|            L       - средняя аномалия Луны                 |
|            L_1     - средняя аномалия Солнца               |
|            F_b     - аргумент широты Луны                  |
|            D_b     - средняя элонгация Луны от Солнцф      |
|                                                            |
|     Используются константы :                               |
|                PI     = 3.14159265358979    TKOC[1]        |
|                R_FAAR = 1296000             TKOC[15]       |
|                                                            |
|                                            10.04.2007      |
|-----------------------------------------------------------*/
void FAARM (double MJD, double *L_b, double *L, double *L_1, double *F_b, double *D_b)
{
	 double T, L_b_rab, L_rab, L_1_rab, F_b_rab, D_b_rab;

     T = (MJD - 51544.5) / 36525.;
     L_b_rab = 785939.157 + (1336 * TKOC[15] + 1108372.598) * T - 5.802 * T * T;
     L_b_rab = TKOC[1] * L_b_rab / 648000.;
     *L_b = L_b_rab  - TKOC[11] * floor(L_b_rab / TKOC[11]);
     L_rab = 485866.733 + (1325 * TKOC[15] + 715922.633) * T + 31.310 * T * T;
     L_rab = L_rab * TKOC[1] / 648000.;
     *L = L_rab  - TKOC[11] * floor(L_rab / TKOC[11]);
     L_1_rab = 1287099.804 + (99 * TKOC[15] + 1292581.224) * T - 0.577 * T * T;
     L_1_rab = L_1_rab * TKOC[1] / 648000.;
     *L_1 = L_1_rab  - TKOC[11] * floor(L_1_rab / TKOC[11]);
     F_b_rab = 335778.877 + (1342 * TKOC[15] + 295263.137) * T - 13.257 * T * T;
     F_b_rab = F_b_rab * TKOC[1] / 648000.;
     *F_b = F_b_rab  - TKOC[11] * floor(F_b_rab / TKOC[11]);
     D_b_rab = 1072261.307 + (1236 * TKOC[15] + 1105601.328) * T - 6.891 * T * T;
     D_b_rab = D_b_rab * TKOC[1] / 648000.;
     *D_b = D_b_rab  - TKOC[11] * floor(D_b_rab / TKOC[11]);
		
}
/******************************** end FAARM ************************************************/

/*------------------------------------------------------------
|                       MNUT                                 |
|     Расчет   матрицы нутации								 |
|                                                            |
|                                                            |
|                                                            |
|     Вход : MJD                                             |
|            MJD        - модифицированная юлианская дата    |
|                                                            |
|     Выход: Nut[3][3]                                       |
|            Nut[3][3]  - матрица нутации                    |
|                                                            |
|     Используются процедуры : FAARM                         |
|                                                            |
|                                            17.06.2004      |
|-----------------------------------------------------------*/
void MNUT (double MJD, double Nut[3][3])
{
	double T ;
    double k1, k2, k3, k4, k5, k6, k7, k8, k9, k10;
    double k11, k12, k13, k14, k15, k16, k17, k18, k19, k20;
    double k21, k22;
    double A1, A2, A3, A4, A5;
	double DELpsi_s,  DELeps_s, eps_0;

    k1  = 8.33860138961157e-005;
	k2  = 9.99685810447863e-007;
	k3  = 6.39323801279145e-006;
	k4  = 6.91344309262198e-007;
	k5  = 1.05204568800769e-007;
	k6  = 2.50648673133630e-007;
	k7  = 6.25409648631301e-008;
	k8  = 1.10246631084308e-006;
	k9  = 3.45187340949990e-007;
	k10 = 1.87138080908281e-007;
	k11 = 1.45928918013970e-007;
	k12 = 5.96320827764729e-008;
	k13 = 7.66005616153067e-008;
	k14 = 4.46149790041050e-005;
	k15 = 4.33908244593035e-007;
	k16 = 2.78089127484430e-006;
	k17 = 1.08598264568536e-007;
	k18 = 4.73662966444017e-007;
	k19 = 9.69627362219072e-008;
	k20 = 6.25409648631301e-008;
    k21 = 0.409092804222329;
	k22 = 0.000226965524811;
  
    T = (MJD - 51544.5) / 36525.;

    FAARM ( MJD, &A1, &A2, &A3, &A4, &A5);
    DELpsi_s = - k1 * sin(A1 - A4) + k2 * sin(2*A1 - 2*A4) - k3 * sin(2*A1 - 2*A5)
		       + k4 * sin(A3) + k5 * sin(2*A1 - 2*A5 - A3) - k6 * sin(2*A1 - 2*A5 + A3)
               + k7 * sin(A1 - 2*A5 + A4) - k8 * sin(2*A1) + k9 * sin(A2)
			   - k10 * sin(A1 + A4) - k11 * sin(2*A1 + A2) + k12 * sin(2*A1 - A2)
			   - k13 * sin(A2 - 2*A5);
    DELeps_s =   k14 * cos(A1 - A4) - k15 * cos(2*A1 - 2*A4) + k16 * cos(2*A1 - 2*A5)
		       + k17 * cos(2*A1 - 2*A5 + A3) + k18 * cos(2*A1) + k19 * cos(A1 + A4)
               + k20 * cos(2*A1 + A2);
	eps_0    =   k21 - k22 * T;
    
	Nut[0][0] = 1.;
	Nut[0][1] = - DELpsi_s * cos(eps_0);
  	Nut[0][2] = - DELpsi_s * sin(eps_0);
	Nut[1][0] =   DELpsi_s * cos(eps_0);
	Nut[1][1] = 1.;
  	Nut[1][2] = - DELeps_s;
  	Nut[2][0] =   DELpsi_s * sin(eps_0);
  	Nut[2][1] =   DELeps_s;
	Nut[2][2] = 1.;

}
/*********************************** end MNUT *********************************************/

/*----------------------------------------------------------------
|                          PREC2000                              |
|    Расчет  матрицы прцессии по модифицированной юлианской дате |
|       ( относительно среднего равноденствия даты (J2000) )     |
|                                                                |
|         Вход : MJD                                             |
|                MJD        - модифицированная юлианская дата    |
|                                                                |
|         Выход: Prec[3][3]                                      |
|                Prec[3][3]  - матрица прецессии                 |
|                                                                |
|     Используются константы :                                   |
|                     PI    = 3.14159265358979  TKOC[1]          |
|                     DVAPI = 6.28318530717959  TKOC[11]         |
|                                                                |
|                                            10.04.2007          |
|---------------------------------------------------------------*/
void PREC2000 (double MJD, double Prec[3][3])
{
	double T ;
    double ksi_A, z_A, teta_A;
	double s_ksi_A, c_ksi_A, s_z_A, c_z_A, s_teta_A, c_teta_A;

    T = (MJD - 51544.5) / 36525;
    ksi_A    = 2306.2181 * T + 0.30188 * T * T;
    ksi_A    = ksi_A * TKOC[1] / 648000;
    ksi_A    = ksi_A - TKOC[11] * floor(ksi_A / TKOC[11]);
    z_A      = 2306.2181 * T + 1.09468 * T * T;
    z_A      = z_A * TKOC[1] / 648000;
    z_A      = z_A - TKOC[11] * floor(z_A / TKOC[11]);
    teta_A   = 2004.3109 * T - 0.42655 * T * T;
    teta_A   = teta_A * TKOC[1] / 648000;
    teta_A   = teta_A - TKOC[11] * floor(teta_A / TKOC[11]);

    s_ksi_A  = sin(ksi_A);
    c_ksi_A  = cos(ksi_A);
    s_z_A    = sin(z_A);
    c_z_A    = cos(z_A);
    s_teta_A = sin(teta_A);
    c_teta_A = cos(teta_A);

    Prec[0][0] = -s_ksi_A * s_z_A + c_ksi_A * c_z_A * c_teta_A;
    Prec[0][1] = -c_ksi_A * s_z_A - s_ksi_A * c_z_A * c_teta_A;
    Prec[0][2] = -c_z_A * s_teta_A;
    Prec[1][0] =  s_ksi_A * c_z_A + c_ksi_A * s_z_A * c_teta_A;
    Prec[1][1] =  c_ksi_A * c_z_A - s_ksi_A * s_z_A * c_teta_A;
    Prec[1][2] = -s_z_A * s_teta_A;
    Prec[2][0] =  c_ksi_A * s_teta_A;
    Prec[2][1] = -s_ksi_A * s_teta_A;
    Prec[2][2] =  c_teta_A;
	
}
/********************************** end PREC2000 ******************************************/

/**********************************************************/
/*                        VOSX_E                          */
/*             Расчет времен восхода,захода КА над        */
/*                    местным горизонтом                  */
/*              (с использованием метода хорд)            */
/*                                                        */
/*   Вход:  t - время привязки вектора  P,                */
/*          P[6] - исходной вектор параметров орбиты,     */
/*          tip  - тип орбиты,                            */
/*          DEL_UT1 - поправка в значение UTC,            */
/*          Npost - номер поста,                          */
/*                                                        */
/*   Выход: tv - время восхода,                           */
/*          tz - время захода                             */
/*                                                        */
/*  Используются процедуры :  FpVZ()                      */
/*                            INT2000()                   */
/*                            POSTM()                     */
/*                                                        */
/*  Используются константы :  TKOC[63] = MU_KP            */
/*                            TKOC[67] = del_v            */
/*                  	      TKOC[68] = del_z            */
/*                                                        */
/**********************************************************/
int VOSX_E(KU_TimeDATA t,double P[6],int tip,double DEL_UT1,int Npost,
		   KU_TimeDATA *tv,KU_TimeDATA *tz)
{
	int i,N;
	Finp_E a;
    KU_TimeDATA t_begin,t_end;
	double t_begin_sec,t_end_sec,t_sec;
	double MI[5][2];
	double del_v,del_z;

	del_v = TKOC[67];
	del_z = TKOC[68];

    t_sec = TIME_t(t);

	t_begin_sec = t_sec - del_v;        //определение интервала поиска
	t_end_sec = t_sec + del_z;

	t_begin = t_TIME(t_begin_sec);
	t_end = t_TIME(t_end_sec);

    for(i = 0; i <= 5; i ++)
		a.p[i] = P[i];

	a.tip = tip;
	a.ta = t;
	a.t.d = 0;
	a.t.s = 0.0;
	a.DEL_UT1 = DEL_UT1;
	a.Npost = Npost;

	KORIN_E(t_begin,t_end,a,FpVZ,&N,MI);

	if(N != 0)
	{
		*tv = t_TIME(MI[0][0]);
		*tz = t_TIME(MI[0][1]);
	}
	else  printf("Входные данные не корректны");

	return (0);

}
/****************************** end VOSX_E ***************************************/

/***************************************************************************************/
double FpVZ(Finp_E a)
{
//    int j;
	double xyz[6],s,mu,mjd,Pp[6];
	KU_TimeDATA tt;
    TimeDATA_u t_k;
	int i;
	
	t_k.d = a.t.d;
	t_k.s = a.t.s;
	t_k.u = 0.0;

	for(i = 0; i <= 5; i ++)
	    Pp[i] = a.p[i];

	INT2000(&a.ta,&t_k,Pp,1,3,a.tip);
 
	tt.d = t_k.d;
	tt.s = t_k.s;

	SMJ2000(&tt,&mjd);
	POSTM(Pp,mjd,a.tip,a.DEL_UT1,a.Npost,xyz);

	s = sqrt (xyz[0 ] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);

	mu = asin( xyz[0]/s);

	return (mu - TKOC[63]);
	
}
/****************************** end FpVZ for VOSX_E ********************************/

/****************************************************************/
/*                     VEKDAT_E                                 */
/*	Определение вектора состояния КА в апогее на заданную дату  */
/*              с учётом протяжённых коррекций                  */
/*                                                              */
/*                                                              */
/*                                                  22.03.2007  */
/****************************************************************/
int VEKDAT_E( //INPUT
			KU_TimeDATA *t0, // время привязки опорного вектора
			double  P0[6],	 // вектор состояния 
			KU_DateDATA *D,  // дата 
			int		tip,	 // тип орбиты 
			int		Pv,		 // признак второго (восточного) витка 
			                 // Pv = 1 - первый виток, Pv = 2 - второй виток    
            KU_MKOR *MK,     // структура  массива коррекций 
			  //OUTPUT
			KU_TimeDATA	*ta, // время привязки опорного вектора в апогее, сутки 
			double  Pa[6]	 //вектор состояния в апогее 
		  )
{
	int  j, ap;
	double t,tta;
	KU_TimeDATA td;

	KDS2000(D, &td);

	t = TIME_t(td);
	j=0;
	
	ap = 1;

	do{

	APSIDK(t0, P0, tip, j, ap, MK, ta, Pa);
	tta = TIME_t(*ta);

	j += 2;

	}while(tta < t);

	if(Pv == 2) APSIDK(ta, Pa, tip, 1, ap, MK, ta, Pa);

	return 0;
}
/****************************** end VEKDAT_E *********************************/ 

/*****************************************************************/
/*                     VEKDAT_RU                                 */
/* Определение вектора состояния КА в начале РУ на заданную дату */
/*              с учётом протяжённых коррекций                   */
/*                                                               */
/*                                                     9.07.2009 */
/*****************************************************************/
int VEKDAT_RU( //INPUT
			 KU_TimeDATA *t0, // время привязки опорного вектора
			 double  P0[6],	  // вектор состояния 
			 KU_DateDATA *D,  // дата 
			 double taB,      // 
			 int		tip,  // тип орбиты 
			 int		Pv,	  // признак второго (восточного) витка 
			                  // Pv = 1 - первый виток, Pv = 2 - второй виток    
             KU_MKOR *MK,     // структура  массива коррекций 
			  //OUTPUT
			 KU_TimeDATA *tru,// время привязки опорного вектора в начале РУ, сутки 
			 double  Pru[6]   // вектор состояния в начале РУ 
		     )
{
	int  i, j, ap, kik;
	double t, tta;
	double Pa[6], Pa1[6];
	KU_TimeDATA td, ta, ta1;

	KDS2000(D, &td);

	t = TIME_t(td);
	j=0;
	
	ap = 1;

	do{

	APSIDK(t0, P0, tip, j, ap, MK, &ta, Pa);
	tta = TIME_t(ta);
 
	if(tta >= t - 86400)                           
	{
		ta1 = ta;
		for(i = 0; i <= 5; i++) Pa1[i] = Pa[i];
	}

	j += 2;

	}while(tta < t);

	if(Pv == 2) APSIDK(&ta, Pa, tip, 1, ap, MK, &ta, Pa);  

	tta = TIME_t(ta);
	*tru = t_TIME(tta - taB); 

	INTK(&ta1, tru, Pa1, tip, MK, &kik, Pru);

	return 0;
}
/****************************** end VEKDAT_RU *********************************/ 

/*---------------------------------------------------------------------
|		                         SOLM                                  |
|	   Программа предназначена для вычисления прямоугольных            |
|     координат SOLM в экваториальной системе координат                |
|     ось Х которой направлена в среднюю точку весеннего               |
|     равноденствия (на момент времени, для которого                   |
|     вычисляются коордтинаты), ось Z направлена по оси                |
|     Мира, а ось Y дополняет систему до правой                        |
|	   psk = 1 - координаты SOLM  в средней экваториальной системе     |
|	   psk = 2 - координаты SOLM  в средней экваториальной системе     |
|				 на эпоху J2000.                                       |
|                                                                      |
|	Вход		:	MJD		- модифицированная юлианская дата в UTC    |
|					psk		- признак выходных координат:              |
|	Выход		:	xl[4]  -  вектор координат Луны                    |
|                                                                      |
|       Используются константы :                                       |
|      AU  = 1.49597870691e+8  астрономическая единица длины   TKOC[21]|
|      RS  = 4.848136811095e-6 число радиан в угловой секунде  TKOC[22]|      
|	   DTT_DTA = 65.184	значения поправки с 1.1.2006           TKOC[60]|
|                                                                      |  
|	                FAARM                                              |
|	                PREC2000                                           |
|					YM_MV_3	                                           |
|---------------------------------------------------------------------*/
void  SOLM(double mjd,  int psk, double xs[4])
{
     double  ec, E, r, l, wc, xlp[3], mjdp, DTT_DTA,
	        t, vc, xse, yse, se, ce, eps, mpr[3][3], tpr[3][3];

	 DTT_DTA = TKOC[60];

    /* Переход от юлианской даты, соответствующей всемирному координированному времени UTC,
	   к юлианской дате, соответствующей земному времени TT */
	 mjdp = mjd + DTT_DTA/86400.0;
	/* Вычисление времени в юлианских столетиях от эпохи J2000 */
 	 t = (mjdp - 51544.5)/36525.0;

    /* Вычисление среднего наклона эклиптики к экватору, */
    /* а также синуса и косинуса этого угла              */
     eps = (84381.448-46.815*t)*TKOC[22];
     se = sin(eps);
     ce = cos(eps);

    /* Вычисление эксцентриситета орбиты Земли */  
	 ec = 0.0167086342 - 0.00004203654*t- 1.2673e-07*t*t;
    /* Вычисление средней долготы солнечного перигея */  
     wc  = (1018578.046 + 6190.046*t+1.666*t*t)*TKOC[22];
    /* Вычисление средней аномалии солнца */  
	 E = (1287099.804 + 129596581.224*t-0.577*t*t)*TKOC[22];
	/*  истинная аномалия Солнца; */
	 vc = E + 2.0*ec*sin(E) + 1.25*ec*ec*sin(2.0*E);
	/*  истинная долгота Солнца;*/
	 l = wc + vc;

	/*  расстояние до Солнца;*/
	 r = (1.0 - ec * ec )/(1.0 + ec*cos(vc)); /** au*/
	/*     эклиптические декартовы координаты Солнца; */
	 xse = cos(l);
	 yse = sin(l);
	/*    Вычисление направляющих косинусов и расстояния */
	 xs[0] = xse;
	 xs[1] = yse * ce;
	 xs[2] = yse * se;
	 xs[3] =   r * TKOC[21];

	 if(psk==2) 
	 {
		PREC2000(mjd, mpr);
        tpr[0][0]=mpr[0][0]; tpr[0][1]=mpr[1][0]; tpr[0][2]=mpr[2][0];
        tpr[1][0]=mpr[0][1]; tpr[1][1]=mpr[1][1]; tpr[1][2]=mpr[2][1];
        tpr[2][0]=mpr[0][2]; tpr[2][1]=mpr[1][2]; tpr[2][2]=mpr[2][2];
        YM_MV_3(tpr, xs, xlp);
        xs[0]=xlp[0];
		xs[1]=xlp[1];
		xs[2]=xlp[2];
	 }
}
/*********************************** end  SOLM ********************************************/

/*-----------------------------------------------------------------------
|		                         LUNM                                   |
|	   Программа предназначена для вычисления прямоугольных             |
|     координат Луны в экваториальной системе координат                 |
|     ось Х которой направлена в среднюю точку весеннего                |
|     равноденствия (на момент времени, для которого                    |
|     вычисляются коордтинаты), ось Z направлена по оси                 |
|     Мира, а ось Y дополняет систему до правой                         |
|	   psk = 1 - координаты Луны  в средней экваториальной системе      |
|	   psk = 2 - координаты Луны  в средней экваториальной системе      |
|				 на эпоху J2000.                                        |  
|                                                                       |  
|	Вход		:	MJD		- модифицированная юлианская дата в UTC     |
|					psk		- признак выходных координат:               |           
|	Выход		:	xl[4]  -  вектор координат Луны                     |             
|                                                                       |              
|       Используются константы :                                        |
|      RS  = 4.848136811095e-6 число радиан в угловой секунде  TKOC[22] |
|	   DTT_DTA = 65.184	значения поправки с 1.1.2006           TKOC[60] |
|                                                                       |
|	                FAARM                                               |
|	                PREC2000                                            |         
|					YM_MV_3	                                            |
------------------------------------------------------------------------*/
void LUNM(double mjd,int psk, double xl[4])
{
    double se,ce,eps,al,alm,alm2,e,f,d,
    	   mpr[3][3],rl,xe,ye,ze, DTT_DTA;
    double d2,all,bl,pl,sl,cl,sb,cb,
           mjdp,tmjd,xlp[3],tpr[3][3];

    DTT_DTA = TKOC[60];

    /* Переход от юлианской даты, соответствующей  UTC,
      к юлианской дате, соответствующей земному времени TT */
      mjdp = mjd + DTT_DTA/86400.0;
    /* Вычисление времени в юлианских столетиях от эпохи J2000 */
      tmjd =(mjdp-51544.5)/36525.0;

    /* Вычисление среднего наклона эклиптики к экватору ep0*/
    /* а также синуса и косинуса этого угла                */
      eps = (84381.448-46.815*tmjd)*TKOC[22];
      se=sin(eps);
      ce=cos(eps);
      FAARM (mjdp,&al,&alm,&e,&f,&d);

      d2  = 2.0*d;
      alm2= 2.0*alm;
   // Вычисление синуса и косинуса эклиптической долготы Луны
      all =(22639.500*sin(alm)
		   -4586.465*sin(alm-d2)
		   +2369.912*sin(d2)
		    +769.016*sin(alm2)
		    -668.146*sin(e)
		    -411.608*sin(2.0*f)
		    -211.656*sin(alm2-d2)
	 	    -205.962*sin(alm+e-d2)
		    +191.953*sin(alm+d2)
	 	    -165.145*sin(e-d2)
		    +147.687*sin(alm-e)
		    -125.154*sin(d)
		    -109.673*sin(alm+e)
            -55.173*sin(2.0*f -d2)
            -45.099*sin(alm +2.0*f)
            +39.528*sin(alm -2.0*f)
            -38.428*sin(alm -2.0*d2)
            +36.124*sin(3.0*alm)
            -30.773*sin(alm2-2.0*d2))*TKOC[22];
      all=al+all;
      sl = sin(all);
      cl = cos(all);
   // Вычисление синуса и косинуса эклиптической широты Луны;
	  bl  =(18461.480*sin(f)
		   +1010.180*sin(f+alm)
		    -999.695*sin(f-alm)
		    -623.658*sin(f-d2)
		    +199.485*sin(f+d2-alm)
		    -166.577*sin(f-d2+alm)
		    +117.262*sin(f+d2)
		     +61.913*sin(alm2+f)
		     -33.359*sin(f-alm-d2)
		     -31.763*sin(f-alm2))*TKOC[22];
      sb = sin(bl);
	  cb = cos(bl);

   //  вычисление синуса параллакса и расстояния Луны
      pl  =  3422.7
		        +186.5398*cos(alm)
			 +34.3117*cos(alm-d2)
			 +28.2333*cos(d2)
			 +10.1657*cos(alm2)
			  +3.0861*cos(alm+d2)
			  +1.9178*cos(e-d2)
			  +1.4437*cos(alm+e-d2)
			  +1.1528*cos(alm-e)
			  -0.9781*cos(d)
			  -0.9490*cos(alm+e)
			  -0.7136*cos(alm-2.0*f);

      rl=1315.646695e+06/pl;

   //  вычислим декартовы координаты в эклиптической системе
		xe=cl*cb;
		ye=sl*cb;
		ze=sb;
   //  перейдем в экваториальную систему эпохи даты
     xl[0] = xe;
     xl[1] = ce*ye - se*ze;
     xl[2] = se*ye + ce*ze;
     xl[3] = rl;

   //  перейдем в экваториальную систему эпохи J2000 
	 if(psk==2) 
	 {
		PREC2000(mjdp, mpr);
        tpr[0][0]=mpr[0][0]; tpr[0][1]=mpr[1][0]; tpr[0][2]=mpr[2][0];
        tpr[1][0]=mpr[0][1]; tpr[1][1]=mpr[1][1]; tpr[1][2]=mpr[2][1];
        tpr[2][0]=mpr[0][2]; tpr[2][1]=mpr[1][2]; tpr[2][2]=mpr[2][2];
        YM_MV_3 (tpr, xl, xlp);
        xl[0]=xlp[0];
	    xl[1]=xlp[1];
	    xl[2]=xlp[2];
	 }
}
/*********************************** end LUNM *********************************************/

/*********************************************************/
/*                      TIME_t                           */
/*    Функция перевода системного векторного времени     */
/*    во время в секундах                                */
/*********************************************************/
double TIME_t(KU_TimeDATA tc)
{
	double t;

	t=tc.d*86400.+tc.s;
	return t;
}
/************************************** end TIME_t ************************************/

/*********************************************************/
/*                      t_TIME                           */
/*    Функция перевода времени в секундах в системное    */
/*    векторное время                                    */
/*********************************************************/
KU_TimeDATA t_TIME(double t)
{
	KU_TimeDATA tc;
	double dn,h;

	h=t/86400.;
	tc.s=86400.* modf(h,&dn);
	tc.d=(int)dn;
	return tc;
}
/************************************ end t_TIME **************************************/

/*******************************************************************/
/*                             Ob_MK                               */
/*                 Объединение массивов коррекций                  */
/*                                                                 */
/*******************************************************************/
void Ob_MK(KU_MKOR *MKORd, KU_MKOR *MKORp, KU_TimeDATA tod, KU_MKOR *MK)
{
	KU_MKORPob MKORob;
	double tod_sec, tn_sec, tn1_sec, tk_sec;
	int i,j,k;

// обнуление структур MKORob(промежуточного массива) и MК(выходного объединённого массива)
	for(i = 0; i < 720; i++)
	{
		for(j = 0; j < 2; j++)
		{
			MKORob.Mtkor[i][j].d = 0;
		    MKORob.Mtkor[i][j].s = 0.0;
		}
		
        for(j = 0; j < 3; j++)  MKORob.MW[i][j] = 0.0;
			
		MKORob.TIPkor[i] = 0;
	}

	MKORob.n_kor = 0;


	for(i = 0; i < 360; i++)
	{
		for(j = 0; j < 2; j++)
		{
			MK -> Mtkor[i][j].d = 0;
		    MK -> Mtkor[i][j].s = 0.0;
		}
		
        for(j = 0; j < 3; j++)  MK -> MW[i][j] = 0.0;
			
		MK -> TIPkor[i] = 0;
	}

	MK -> n_kor = 0;


// объединение массивов действующих и планируемых коррекций
// в промежуточном массиве размерностью на 720 элементов
	k = 0;

	for(i = 0; i < MKORd ->n_kor; i++)
	{
			for(j = 0; j < 2; j++)	MKORob.Mtkor[k][j] = MKORd -> Mtkor[i][j];
			for(j = 0; j < 3; j++)  MKORob.MW[k][j] = MKORd -> MW[i][j];
				
			MKORob.TIPkor[k] = MKORd -> TIPkor[i];

			k++;
	}

	for(i = 0; i < MKORp ->n_kor; i++)
	{
			for(j = 0; j < 2; j++)	MKORob.Mtkor[k][j] = MKORp -> Mtkor[i][j];
			for(j = 0; j < 3; j++)  MKORob.MW[k][j] = MKORp -> MW[i][j];
				
			MKORob.TIPkor[k] = MKORp -> TIPkor[i];

			k++;
	}

	MKORob.n_kor = MKORd ->n_kor + MKORp ->n_kor;


	tod_sec = TIME_t(tod);

// время tod меньше начала нулевого интервала промежуточного массива коррекций
	tn_sec = TIME_t(MKORob.Mtkor[0][0]);

	if(tod_sec < tn_sec)
	{
		for(i = 0; i < 360; i++)  
		{
			for(k = 0; k < 2; k++)  MK -> Mtkor[i][k] = MKORob.Mtkor[i][k];
			for(k = 0; k < 3; k++)  MK -> MW[i][k] = MKORob.MW[i][k];
			MK -> TIPkor[i] = MKORob.TIPkor[i];

			if(MK -> TIPkor[i] != 0) MK -> n_kor = MK -> n_kor + 1;              
		}

		return;                
	}


// отыскание первого интервала объединенного массива коррекций
	for(i = 0; i < 720; i++)
	{
		tn_sec = TIME_t(MKORob.Mtkor[i][0]);
		tk_sec = TIME_t(MKORob.Mtkor[i][1]); 

		if((tn_sec <= tod_sec) && (tod_sec < tk_sec))
		{
			MK -> Mtkor[0][0] = tod;
			MK -> Mtkor[0][1] = MKORob.Mtkor[i][1];
			
			for(j = 0; j < 3; j++)  MK -> MW[0][j] = MKORob.MW[i][j];

			MK -> TIPkor[0] = MKORob.TIPkor[i];

			MK -> n_kor = 1;

			break;
		}

		if(i != 719)
		{
			tn1_sec = TIME_t(MKORob.Mtkor[i + 1][0]);

			if((tk_sec <= tod_sec) && (tod_sec < tn1_sec))
			{
				for(j = 0; j < 2; j++)  MK -> Mtkor[0][j] = MKORob.Mtkor[i + 1][j];
				for(j = 0; j < 3; j++)  MK -> MW[0][j] = MKORob.MW[i + 1][j];

				MK -> TIPkor[0] = MKORob.TIPkor[i + 1];

				MK -> n_kor = 1;
            
				i++;

				break;
			}
		}

	}

// заполнение остальных интервалов объединенного массива коррекций
	if(MK -> n_kor == 1)
	{
		i++;

		for(j = 1; j < 360; j++)
		{
			if(i < 720)
			{
				if(MKORob.TIPkor[i] != 0)
				{
					for(k = 0; k < 2; k++)  MK -> Mtkor[j][k] = MKORob.Mtkor[i][k];
					for(k = 0; k < 3; k++)  MK -> MW[j][k] = MKORob.MW[i][k];
					MK -> TIPkor[j] = MKORob.TIPkor[i];

					MK -> n_kor = MK -> n_kor + 1;
				}
				else j--;
				i++;
			}
			else break;
		}
	}
}
/************************************** end Ob_MK *******************************************/

/****************************************************/
/* Программа чтения констант из файла TKOC_2000.txt */
/*                                                  */    
/*                                       22.03.2007 */
/****************************************************/
void tabk()
{
	char kolich [100];
	int i,j,N_TKOCmax,N_TKOC;
	FILE *in;	

/* 1 */	
	if ((in = fopen("TKOC_2000.txt", "r")) == NULL)
	{
		fprintf(stderr, "1 Cannot open input file TKOC_2000.txt\n");
		exit(0);		
	}else
	{
        printf("1 open input file TKOC_2000.txt\n");
	}

/* 2 */	
	fgets (kolich,100,in);
	fscanf(in, "%d \n", &N_TKOCmax);                        // N_TKOCmax 
		for (i=0; i<N_TKOCmax; i++)
		{
           TKOC[i] = 1.0e+17;
		}

/* 3 */
     fgets (kolich,100,in);
     fscanf(in, "%d \n", &N_TKOC);                          // N_TKOC 
     for (i=0; i<N_TKOC;i++)
	 {
         fgets (kolich,100,in);
		 fscanf(in, " %d  %s \n", &j,kolich); 
         TKOC[i]   = atof ( kolich);
	 }

/* 4 */	 
	fclose(in); // из TKOC_2000.txt считали все элементы TKOC 
}
/*****************************************************************************************/

/***********************************************/
/* Программа чтения констант из файла MKC.txt  */
/*                                             */    
/*                                  22.03.2007 */
/***********************************************/
void tabk_mkc()
{
	char kolich [100];
	int i,Kpost;
	FILE *in;	

/* 1 */	
	if ((in = fopen("MKC.txt", "r")) == NULL)
	{
		fprintf(stderr, "1 Cannot open input file MKC.txt\n");
		exit(0);		
	}else
	{
 		printf("1 open input file MKC.txt\n");
	}

/* 2*/
	fgets (kolich,100,in);
	fscanf(in, "%d \n", &Kpost);
	fgets (kolich,100,in);

/* 3 */
	for (i=0; i<Kpost*8;i++)
	 {
         fscanf(in, " %s \n", kolich); 
         MKC[i]   = atof ( kolich);
	 }

/* 4 */
    fclose(in);// из MKC.txt считали все элементы MKC 

}
/**************************************************************************************/

/************************************************************/
/*                     Fprc                                 */
/*															*/
/*           Программа формирования файла                   */
/*	     регистрации процесса расчёта комплексного          */
/*                     алгоритма                            */
/*                                             20.04.2007   */
/************************************************************/
void Fprc(char str[15], char str1[15])
{
    FILE *fp;
	
/* 1 */
	if ((fp = fopen(str1, "at")) == NULL)
	{
		fprintf(stderr, "1 Cannot open input file %s\n", str1);
		exit(0);		
	}
	else
	{
        printf("1 open input file %s\n", str1);
	}

/* 2 */
    fprintf(fp,"          ");
	fprintf(fp,"%s\n",str);

/* 3 */
    fclose(fp);
}

/************************************* end Fprc *************************************/

/************************************************************/
/*                      FprcEnd                             */
/*															*/
/*           Программа формирования завершающего            */
/*                 сообщения в файле                        */
/*	     регистрации процесса расчёта комплексного          */
/*                     алгоритма                            */
/*                                              20.04.2007  */
/************************************************************/
void FprcEnd(char str[15], char str1[15])
{
    FILE *fp;
	
/* 1 */
	if ((fp = fopen(str1, "at")) == NULL)
	{
		fprintf(stderr, "1 Cannot open input file %s\n", str1);
		exit(0);		
	}
	else
	{
        printf("1 open input file %s\n", str1);
	}

/* 2 */
	fprintf(fp,"\n      %s",str);
	fprintf(fp,"    Calculation is completed.\n\n\n ");

/* 3 */
    fclose(fp);
}

/************************************ end FprcEnd *************************************/

/************************************************************/
/*                      FprcCancel                          */
/*															*/
/*           Программа формирования завершающего            */
/*       сообщения о невозможности расчета в файле          */
/*	     регистрации процесса расчёта комплексного          */
/*                     алгоритма                            */
/*                                              10.09.2009  */
/************************************************************/
void FprcCancel(char str[15], char str1[15])
{
    FILE *fp;
	
/* 1 */
	if ((fp = fopen(str1, "at")) == NULL)
	{
		fprintf(stderr, "1 Cannot open input file %s\n", str1);
		exit(0);		
	}
	else
	{
        printf("1 open input file %s\n", str1);
	}

/* 2 */
	fprintf(fp,"\n      %s",str);
	fprintf(fp,"    Calculation is impossible.\n\n\n ");

/* 3 */
    fclose(fp);
}

/************************************ end FprcCancel **********************************/

/**************************************************************************************/
KU_TimeDATA get_ibm_sys_times70(KU_DateDATA *D)
{

	KU_TimeDATA t;
	time_t times;
	
	int ai, j, i, s[12], ft, dn;

/* 1 */
// определение текущего календарного времени в секундах 		
	time(&times);

/* 2 */
	times = times + 3 * 3600;

/* 3 */
// перевод текущего календарного времени из секунд в сутки, секунды 
	t = t_TIME(times);

/* 4 */	
	D->m = 1;
	D->d = 1;
	D->y = 1970;
	ft = t.d;

/* 5 */
	for (i=1; i<=12;i++)  s [i-1]=31;
	for (i=4; i<=6;i=i+2)
		 {
		 s[i-1] = 30;
		 s[i+4] = 30;
		 }
	s[1] = 28;

/* 6 */
	dn = 365;
	if ( D->y == D->y / 4 * 4) dn = dn + 1;
	while ( ft >= dn)
		{
		ft = ft - dn;
		D->y = D->y + 1;
		dn = 365;
		if ( D->y == D->y / 4 * 4) dn = dn + 1;
		}

/* 7 */
	s[1] = s[1] + dn - 365;
	j = 1;
	while (ft >= s[j-1])
		{
		ft = ft - s [j-1];
		j = j + 1;
		}
	D->m = j;

/* 8 */
	D->d = ft + D->d;

/* 9 */
	D->h = (int) t.s / 3600;

/* 10 */
	ai = (int)(t.s - (double)D->h * 3600);
	D->min = ai / 60;

/* 11 */
	D->sec = (t.s - (double)D->h * 3600) - (double)D->min * 60;

	return t;

}
/*****************************************************************************************/

/**********************************************************************************/
/*                                                                                */
/*     Блок расчета составляющих вектора скорости движения центра масс Земли      */
/*                                                                                */
/*                      на заданный момент времени в ИГСК                         */
/*                                                                                */
/*                     (Собств. блок алгоритма VIZIR_ZV)                          */
/*                                                                                */
/* Version 09.06.2012                                                             */
/**********************************************************************************/

 /**********************************************************************************/
/*                                                                                */
/*     Блок расчета составляющих вектора скорости движения центра масс Земли      */
/*                                                                                */
/*                      на заданный момент времени в ИГСК                         */
/*                                                                                */
/*                     (Собств. блок алгоритма VIZIR_ZV)                          */
/*                                                                                */
/* Version 09.06.2012                                                             */
/**********************************************************************************/

void V_Terra(KU_TimeDATA *t,
			 double v[3])
{
double mjd, r, r1;
double p[4], p1[4];
double dd = 0.1;
int i;
SMJ2000(t, &mjd);
mjd+=dd;
SOLM(mjd, 2, p1);
r1 = p1[3];
mjd-=2.0*dd;
SOLM(mjd, 2, p);
r = p[3];
for (i = 0; i<=2; i++)
v[i] = (r*p[i]-r1*p1[i])/(2.0*dd*Tcc);
}

/**********************************************************************************/
/*                                                                                */
/*      Алгоритм определения положения звезды в визирной системе координат        */
/*                                                                                */
/* Version 09.06.2012                                                             */
/**********************************************************************************/
void VIZIR_ZV(KU_TimeDATA *t,  //Системное время
			  double F[3][3],  //Матрица ориентации
			  double p[6],     //Вектор орбитальных параметров КА
			  double at,       //Прямое восхождение звезды в момент наблюдения
			  double dt,       //Склонение звезды в момент наблюдения
			  //exit
			  double *at_ab,   //Прямое восхождение зв с учетом звездной аберрации
			  double *dt_ab,   //Склонение зв с учетом звездной аберрации
			  double zv_ab[3], //Напр кос звезды в ИГСК с учетом зв аберрации
			  double ssk[3]   //Напр кос звезды в ССК с учетом зв аберрации
//			  double *alfa,
//			  double *beta
			  )
{
double r[6], x[6], vt[3];
double dd, da;
int i;
PIRM(p, r);
DECORM(r, 2, x);
V_Terra(t,vt);
for (i = 0; i<3; i++)
		vt[i]+=x[i+3];
dd = (vt[2]*cos(dt)-vt[0]*sin(dt)*cos(at)-vt[1]*sin(dt)*sin(at))/Cv;
da = (vt[1]*cos(at)-vt[0]*sin(at))/(Cv*cos(dt));
*at_ab = at + da;
*dt_ab = dt + dd;
zv_ab[0] = cos(*at_ab)*cos(*dt_ab);
zv_ab[1] = sin(*at_ab)*cos(*dt_ab);
zv_ab[2] = sin(*dt_ab);
YM_MV_3(F,zv_ab,ssk);
//*alfa=-1.*atan(ssk[2]/ssk[0]);
//*beta=-1.*arcsn(ssk[1]/sqrt(ssk[0]*ssk[0]+ssk[1]*ssk[1]+ssk[2]*ssk[2]));
return;
}



