/*  proc.c
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
//#include <time.h>


#include "sysconst.h"
#include "proc1.h"

const double eps1=0.00000000001;
const double eps2=0.0000000001;
const double eps3=0.00006;
double randm = 0.21387645;


double STF(AnsiString SS)   //for w10
{   double dt;
	AnsiString SSc;
	int ii,L;
	char t;
	t='.'; //dlya w7
//	t=','; //dlya w10
	L=SS.Length();
	for (ii=1;ii<=L;ii++)
	{
	 if (SS[ii]==t)
	 {

	  SS[ii]=','; //dlya w7
//	  SS[ii]='.'; //dlya w10
	 }
	}
	return(StrToFloat(SS));
}
void STFi3gms(AnsiString SS,
			double *p0, double *p1,double *p2)
{   double dt,pk[3];
	int ii,jj,L,pn;
	char t,t2,t3,t4,t5,t6,t7,t8;
	AnsiString SSc;
	t='.'; //dlya w7
//	t=','; //dlya w10
	t2=' ';
	t3='\0';
	t4=';';
	t5='°';
	t6='′';
	t7=39;
	t8='″';
	jj=0;
	ii=1;
	SS=SS+' ';
	L=SS.Length();
	pn=0;
	pk[0]=pk[1]=pk[2]=0.0;
	while(jj<3&&ii<L+1)
	{
	 if (SS[ii]==t)
	 {
	  SS[ii]=','; //dlya w7
//	  SS[ii]='.'; //dlya w10
	 }
	 if (SS[ii]==t4||SS[ii]==t5||SS[ii]==t6||SS[ii]==t8||SS[ii]==t7)
	 {
	  SS[ii]=' ';
	 }
	 if (SS[ii]==t2||SS.Length()==ii)
	 {
	   SSc=SS.SubString(pn,ii-pn);
	   pn=ii+1;
	   pk[jj]=StrToFloat(SSc);
	   jj++;
	 }
	 ii++;
	}
	*p0=pk[0];
	*p1=pk[1];
	*p2=pk[2];
}
void STFi6(AnsiString SS,
			double *p0, double *p1,double *p2,double *p3,double *p4,double *p5)
{   double dt,pk[6];
	int ii,jj,L,pn;
	char t,t2,t3,t4;
	AnsiString SSc;
	t='.'; //dlya w7
//	t=','; //dlya w10
	t2=' ';
	t3='\0';
	t4=';';
	jj=0;
	ii=1;
	SS=SS+' ';
	L=SS.Length();
	pn=0;
	while(jj<6)
	{
	 if (SS[ii]==t)
	 {
	  SS[ii]=','; //dlya w7
//	  SS[ii]='.'; //dlya w10
	 }
	 if (SS[ii]==t4)
	 {
	  SS[ii]=' ';
	 }
	 if (SS[ii]==t2||SS.Length()==ii)
	 {
	   SSc=SS.SubString(pn,ii-pn);
	   pn=ii+1;
	   pk[jj]=StrToFloat(SSc);
	   jj++;
	 }
	 ii++;
	}
	*p0=pk[0];
	*p1=pk[1];
	*p2=pk[2];
	*p3=pk[3];
	*p4=pk[4];
	*p5=pk[5];
}

/***************************************************************************/
/* Умножение матрицы на вектор                                             */
/***************************************************************************/
void umnmatrv(double a[3][3], /* матрица                                   */
              double v[3],    /* вектор                                    */
              double v1[3]    /* результирующий вектор                     */
              )
{int i,j; double s;
 for (i=0;i<3;i++)
     {s=0.0;
      for (j=0;j<3;j++)
          s = s + a[i][j]*v[j];
      v1[i] = s;
     }
}

double uvsk(double a[3],double b[3])
{double d;
d = a[0]*b[0]+a[1]*b[1]+a[2]*b[2];
return d;
}
/***************************************************************************/
/* функция одного  аpгумента,  аналог  функции  ARCCOS.                    */
/* Отличается от ARCCOS pасшиpенной областью опpеделения.                  */
/***************************************************************************/
//double arccs(double x /* значение косинуса угла                            */
 /*           )
{
 if((x > -1.0) && (x < 1.0))  return(acos(x));
 else if(x >= 1.0)  return(0.0);
      else   return(PI);
}*/
/***************************************************************************/
/* функция одного  аpгумента,  аналог  функции  ARCSIN.                    */
/* Отличается от ARCSIN pасшиpенной областью опpеделения.                  */
/***************************************************************************/
//double arcsn(double x /* значение синуса угла                            */
 /*           )
{
 if((x > -1.0) && (x < 1.0))  return(asin(x));
 else if(x >= 1.0)  return(PINADVA);
      else   return(-PINADVA);
}*/
/***************************************************************************/
/* норма вектора                                                           */
/***************************************************************************/
double modul(double xv[3])
{  return(sqrt(xv[0]*xv[0] + xv[1]*xv[1] + xv[2]*xv[2]));
}           /*Modul*/
/***************************************************************************/
/* Угол между векторами.                                                   */
/***************************************************************************/
double ugol(double x[3],double y[3])
{double prnm;
 prnm=modul(x)*modul(y);
 if (prnm < eps1)     return(0.0);
 else                 return(arccs((x[0]*y[0] + x[1]*y[1] + x[2]*y[2]) / prnm));
}

/***************************************************************************/
/*  Функция двух аpгументов.  Позволяет  опpеделить                        */
/*  по  значению  синуса  угла и знаку косинуса угла величину самого       */
/*  угла ( в интеpвале [0,2*PI]).                                          */
/***************************************************************************/
double arcsincirc(double si, /* синус угла                                 */
                  double co  /* косинусус угла                             */
                  )
{
  if (fabs(si) > 1.0)
	 return(PI - PINADVA * sign(si));
  else {if ((si >= 0.0) && (co >= 0.0)) return(asin(si));
		else  {if (co <= 0.0)           return(PI - asin(si));
			   else                     return(DVAPI + asin(si));
              }
        }
}
/***************************************************************************/
/* знак числа                                                              */
/***************************************************************************/
int sign(double x)
{if (x < 0.0)        return(-1);
 else  {if (x > 0.0) return(1);
        else         return(0);
       }
}


/***************************************************************************/
/* Транспонирование матрицы                                                */
/***************************************************************************/
void transma(double a[3][3],
             double at[3][3])
{int i,j;
 for (i=0;i<3;i++)
    for (j=0;j<3;j++)
	   at[i][j]=a[j][i];
}
/***************************************************************************/
/* Скалярное произведение двух векторов                                    */
/***************************************************************************/
double skalpr(double x[3],double y[3])
{ return(x[0]*y[0] + x[1]*y[1] + x[2]*y[2]);
}
/***************************************************************************/
/* Линейная   комбинация  двух векторов                                    */
/***************************************************************************/
void lkomb(double a,double va[3],double b,double vb[3],
           double c[3])
{ int i;
  for (i=0;i<3;i++)
       c[i] = a * va[i] + b * vb[i];
}
/****************************************************************************/
/* Векторное умножение                                                      */
/****************************************************************************/
void vektumn(double v1[3],double v2[3],
             double v3[3])
{
 v3[0] = v1[1] * v2[2] - v1[2] * v2[1];
 v3[1] = v1[2] * v2[0] - v1[0] * v2[2];
 v3[2] = v1[0] * v2[1] - v1[1] * v2[0];
}
/***************************************************************************/
/* Произведение   двух матриц                                              */
/***************************************************************************/
void umnmama(double a[3][3],double b[3][3],
             double ab[3][3])
{
 int i,j,l;
 double s;
 for (i=0;i<3;i++)
     {for (j=0;j<3;j++)
        {s = 0.0;
         for (l=0;l<3;l++)
           s = s + a[i][l] * b[l][j];
         ab[i][j] = s;
        }
     }
}
/****************************************************************************/
/* Заполнение матрицы значениями                                            */
/****************************************************************************/
void zapoln(double m[3][3],double m00,double m01,double m02,
                           double m10,double m11,double m12,
                           double m20,double m21,double m22 )
{
m[0][0]=m00;m[0][1]=m01;m[0][2]=m02;
m[1][0]=m10;m[1][1]=m11;m[1][2]=m12;
m[2][0]=m20;m[2][1]=m21;m[2][2]=m22;
}
/****************************************************************************/
/* Матpица повоpота вокpуг оси Х                                            */
/****************************************************************************/
void mxp(double x,double m[3][3])
{
  double cx, sx;
  cx = cos(x);
  sx = sin(x);
  zapoln(m,1.0, 0.0, 0.0,
           0.0,  cx,  sx,
           0.0, -sx,  cx);
}
/****************************************************************************/
/* Матpица повоpота вокpуг оси Y                                            */
/****************************************************************************/
void myp(double y,double m[3][3])
{
  double cy, sy;
  cy = cos(y);
  sy = sin(y);
  zapoln(m, cy,  0.0, -sy,
           0.0,  1.0, 0.0,
            sy,  0.0 , cy);
}
/****************************************************************************/
/* Матpица повоpота вокpуг оси Z                                            */
/****************************************************************************/
void mzp(double z,double m[3][3])
{
  double cz, sz;
  cz = cos(z);
  sz = sin(z);
  zapoln(m, cz,  sz, 0.0,
           -sz,  cz, 0.0,
           0.0, 0.0, 1.0 );
}
/***************************************************************************/
/* Ноpмиpование вектоpа                                                    */
/***************************************************************************/
int normv(double x[3])      /*параметр возврата:1-вектор нормируется
						0-слишком маленький  */
{ double m;
 int pv=1;
 m=modul(x);
 if (m > eps1){
     x[0]=x[0]/m; x[1]=x[1]/m; x[2]=x[2]/m;
 }
 else
   {
   pv=0;
   x[0]=0.0;x[1]=0;x[2]=0;
   }
 return (pv);
}

/******************************************************************/
/** Копирование матрицы********************************************/
/******************************************************************/
void maAvmaB(double A[][3],double B[][3])
{
	int i,j;
	for (i=0;i<3;i++)
		for (j=0;j<3;j++)
			B[i][j]=A[i][j];
}

/******************************************************************/
/** Копирование вектора********************************************/
/******************************************************************/
void avb(double a[],double b[])
{
	int i;
	for (i=0;i<3;i++)
		b[i]=a[i];
}
void avb6(double a[],double b[])
{
	int i;
	for (i=0;i<6;i++)
		b[i]=a[i];
}

void uvv(double a[3],double b[3],double c[3])
{
c[0] = a[1]*b[2]-a[2]*b[1];
c[1] = a[2]*b[0]-a[0]*b[2];
c[2] = a[0]*b[1]-a[1]*b[0];
}
double modv(double a[3])
{double b;
b = sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);
return b;
}
void normv1(double a[3], double b[3])
{
double f;
int i;
f = modv(a);
for(i = 0; i<3; i++)
     b[i] = a[i]/f;
}
/*****************************************************************/
/* Преобразование радиан в градусы и минуты угловые */
/*****************************************************************/
void radgrmi(double rad, int *gr, double *mi)
{
  double ra;
    if (rad >= 0)
     ra = rad - 2.0*PI*floor (rad/(2.0*PI));
    else
     ra = rad - 2.0*PI*ceil(rad/(2.0*PI));
    if (ra >= 0)
     *gr = (int)floor (ra/GR);
    else
     *gr = (int)ceil (ra/GR);
    if ( (ra < 0) && (*gr == 0))
     *mi = ra/MR;
    else
     *mi =  fabs (ra - *gr * GR)/MR;
}
 void umm(double a[3][3],double b[3][3], double c[3][3])
{
double f;
int i, j, k;
for(i = 0; i<3; i++)
for(j = 0; j<3; j++)
    {f = 0;
        for(k = 0; k<3; k++)
        f += a[i][k]*b[k][j];
   c[i][j] = f;
}}
/***************************************************************************/
/*Перевод из сферических координат в декартовы                              */
/***************************************************************************/
void perdsrx(/*** вход ***/
	       double d, /* долгота (рад) */
	       double s, /* широта (рад) */
	       double r, /* радиус */
	       /*** выход ****/
	       double xv[3] /* прямоуг. координаты */
	       )
   {
     xv[0]=r*cos(s)*cos(d);
     xv[1]=r*cos(s)*sin(d);
     xv[2]=r*sin(s);
   }
/***************************************************************************/
/* Перевод из декартовых координат в  сферические							*/
/***************************************************************************/
void perxdsr(/*** вход ***/
	       double xv[3], /* прямоуг. координаты  */
	       /*** выход ***/
	       double *d,    /* долгота (рад) */
	       double *s,    /* широта (рад) */
	       double *r     /* радиус */
	       )
   {
     double cs=0.0;
     *r=sqrt(xv[0]*xv[0]+xv[1]*xv[1]+xv[2]*xv[2]);
     if (*r < eps1)
      {*s=0.0;
       *d=0.0;
      }
     else
     { *s=PINADVA - arccs( xv[2] /  *r);
       cs=sqrt(xv[0]*xv[0]+xv[1]*xv[1] );
       if (cs<eps1)
			*d=0;
       else
		  *d=arcsincirc(xv[1]/cs,xv[0]);
     }
   }
/***************************************************************************/
/*	Нормальное распределение N(0,1) из ЦПТ									*/
/****************************************************************************/
void normRasp(
			  double *r
			  )
{
	double s;
	int i;
	s = 0;
//	srand( (unsigned)time( NULL ) );
	for(i = 1; i <= 5; i++)
	{
		s = s + (rand()*2.0/RAND_MAX-1.0);
	}
	*r = (s)*3.0/sqrt(5.0);
}
/***************************************************************************/
/*	нахождение максимального и минимального значения матрицы				*/
/***************************************************************************/
void mtrxlim(//вход
			int n,
			double buf[],
			//выход
			double *efmax,
			double *efmin,
			double *efsr
			 )
	{
	double c = 0, c1 = 0;
	int i;
	double efmx=0, efmn=1;
		for(i = 0; i <= n-1; i++){


				if(efmn > buf[i])
					efmn = buf[i];
				c+=buf[i];
				c1++;
				if(efmx < buf[i])
					efmx = buf[i];


		}
		*efmin=efmn;
		*efmax=efmx;
		*efsr = c/c1;

	}
/***************************************************************************/
/*	нахождение обратной матрицы	3на3			*/
/***************************************************************************/
void minusA(//вход
			double A[3][3],
			//выход
			double B[3][3]
			 )
	{
		int i, j;
		double d;
		d = A[0][0]*(A[1][1]*A[2][2] - A[1][2]*A[2][1]) - A[0][1]*(A[1][0]*A[2][2] - A[1][2]*A[2][0]) + A[0][2]*(A[1][0]*A[2][1] - A[1][1]*A[2][0]);
		for(i = 0; i <= 2; i++)
		{
			for(j = 0; j <= 2; j++)
			{
				B[i][j] = det(A, j, i)*pow(-1, (i+j))/d;
			}
		}
	}
/***************************************************************************/
/*	нахождение минора	2на2		*/
/***************************************************************************/
double det(
			double A[3][3],
			int i,
			int j
			 )
	{
		int i1, j1, c1, c2;
		double d, A1[2][2];
		c1 = 0;
		c2 = 0;
		for(i1 = 0; i1 <= 2; i1++)
		{
			if(i1 != i)
			{
				c2 = 0;
				for(j1 = 0; j1 <= 2; j1++)
				{
					if(j1 != j)
					{
						A1[c1][c2] = A[i1][j1];
						c2 = c2 + 1;
					}
				}
				c1 = c1 + 1;
			}
		}
		d = A1[0][0]*A1[1][1] - A1[0][1]*A1[1][0];
		return d;
	}
/***************************************************************************/
/*	нахождение обратной матрицы	4на4			*/
/***************************************************************************/
void minusA4(//вход
			double A[4][4],
			//выход
			double B[4][4]
			 )
	{
		int i, j;
		double d, d1;
		d = A[0][0]*(A[1][1]*(A[2][2]*A[3][3] - A[2][3]*A[3][2]) - A[1][2]*(A[2][1]*A[3][3] - A[2][3]*A[3][1]) + A[1][3]*(A[2][1]*A[3][2] - A[2][2]*A[3][1])) -
			A[0][1]*(A[1][0]*(A[2][2]*A[3][3] - A[2][3]*A[3][2]) - A[1][2]*(A[2][0]*A[3][3] - A[2][3]*A[3][0]) + A[1][3]*(A[2][0]*A[3][2] - A[2][2]*A[3][0])) +
			A[0][2]*(A[1][0]*(A[2][1]*A[3][3] - A[2][3]*A[3][1]) - A[1][1]*(A[2][0]*A[3][3] - A[2][3]*A[3][0]) + A[1][3]*(A[2][0]*A[3][1] - A[2][1]*A[3][0])) -
			A[0][3]*(A[1][0]*(A[2][1]*A[3][2] - A[2][2]*A[3][1]) - A[1][1]*(A[2][0]*A[3][2] - A[2][2]*A[3][0]) + A[1][2]*(A[2][0]*A[3][1] - A[2][1]*A[3][0]));
		for(i = 0; i <= 3; i++)
		{
			for(j = 0; j <= 3; j++)
			{
				d1 = det3(A, j, i);
				B[i][j] = d1*pow(-1, (i+j))/d;
			}
		}
	}
/***************************************************************************/
/*	нахождение минора	3на3		*/
/***************************************************************************/
double det3(
			double A[4][4],
			int i,
			int j
			 )
	{
		int i1, j1, c1, c2;
		double d, A1[3][3];
		c1 = 0;
		c2 = 0;
		for(i1 = 0; i1 <= 3; i1++)
		{
			if(i1 != i)
			{
				c2 = 0;
				for(j1 = 0; j1 <= 3; j1++)
				{
					if(j1 != j)
					{
						A1[c1][c2] = A[i1][j1];
						c2 = c2 + 1;
					}
				}
				c1 = c1 + 1;
			}
		}
		d = A1[0][0]*(A1[1][1]*A1[2][2] - A1[1][2]*A1[2][1]) - A1[0][1]*(A1[1][0]*A1[2][2] - A1[1][2]*A1[2][0]) + A1[0][2]*(A1[1][0]*A1[2][1] - A1[1][1]*A1[2][0]);
		return d;
	}
/***************************************************************************/
/*	нахождение обратной матрицы	5на5									   */
/***************************************************************************/
void minusA5(//вход
			double A[5][5],
			//выход
			double B[5][5]
			 )
	{
		int i, j;
		double d, d1;
		d = A[0][0]*(A[1][1]*(A[2][2]*(A[3][3]*A[4][4] - A[3][4]*A[4][3]) - A[2][3]*(A[3][2]*A[4][4] - A[3][4]*A[4][2]) + A[2][4]*(A[3][2]*A[4][3] - A[3][3]*A[4][2])) -
					 A[1][2]*(A[2][1]*(A[3][3]*A[4][4] - A[3][4]*A[4][3]) - A[2][3]*(A[3][1]*A[4][4] - A[3][4]*A[4][1]) + A[2][4]*(A[3][1]*A[4][3] - A[3][3]*A[4][1])) +
					 A[1][3]*(A[2][1]*(A[3][2]*A[4][4] - A[3][4]*A[4][2]) - A[2][2]*(A[3][1]*A[4][4] - A[3][4]*A[4][1]) + A[2][4]*(A[3][1]*A[4][2] - A[3][2]*A[4][1])) -
					 A[1][4]*(A[2][1]*(A[3][2]*A[4][3] - A[3][3]*A[4][2]) - A[2][2]*(A[3][1]*A[4][3] - A[3][3]*A[4][1]) + A[2][3]*(A[3][1]*A[4][2] - A[3][2]*A[4][1]))) -

			A[0][1]*(A[1][0]*(A[2][2]*(A[3][3]*A[4][4] - A[3][4]*A[4][3]) - A[2][3]*(A[3][2]*A[4][4] - A[3][4]*A[4][2]) + A[2][4]*(A[3][2]*A[4][3] - A[3][3]*A[4][2])) -
					 A[1][2]*(A[2][0]*(A[3][3]*A[4][4] - A[3][4]*A[4][3]) - A[2][3]*(A[3][0]*A[4][4] - A[3][4]*A[4][0]) + A[2][4]*(A[3][0]*A[4][3] - A[3][3]*A[4][0])) +
				     A[1][3]*(A[2][0]*(A[3][2]*A[4][4] - A[3][4]*A[4][2]) - A[2][2]*(A[3][0]*A[4][4] - A[3][4]*A[4][0]) + A[2][4]*(A[3][0]*A[4][2] - A[3][2]*A[4][0])) -
					 A[1][4]*(A[2][0]*(A[3][2]*A[4][3] - A[3][3]*A[4][2]) - A[2][2]*(A[3][0]*A[4][3] - A[3][3]*A[4][0]) + A[2][3]*(A[3][0]*A[4][2] - A[3][2]*A[4][0]))) +

			A[0][2]*(A[1][0]*(A[2][1]*(A[3][3]*A[4][4] - A[3][4]*A[4][3]) - A[2][3]*(A[3][1]*A[4][4] - A[3][4]*A[4][1]) + A[2][4]*(A[3][1]*A[4][3] - A[3][3]*A[4][1])) -
					 A[1][1]*(A[2][0]*(A[3][3]*A[4][4] - A[3][4]*A[4][3]) - A[2][3]*(A[3][0]*A[4][4] - A[3][4]*A[4][0]) + A[2][4]*(A[3][0]*A[4][3] - A[3][3]*A[4][0])) +
					 A[1][3]*(A[2][0]*(A[3][1]*A[4][4] - A[3][4]*A[4][1]) - A[2][1]*(A[3][0]*A[4][4] - A[3][4]*A[4][0]) + A[2][4]*(A[3][0]*A[4][1] - A[3][1]*A[4][0])) -
					 A[1][4]*(A[2][0]*(A[3][1]*A[4][3] - A[3][3]*A[4][1]) - A[2][1]*(A[3][0]*A[4][3] - A[3][3]*A[4][0]) + A[2][3]*(A[3][0]*A[4][1] - A[3][1]*A[4][0]))) -

			A[0][3]*(A[1][0]*(A[2][1]*(A[3][2]*A[4][4] - A[3][4]*A[4][2]) - A[2][2]*(A[3][1]*A[4][4] - A[3][4]*A[4][1]) + A[2][4]*(A[3][1]*A[4][2] - A[3][2]*A[4][1])) -
					 A[1][1]*(A[2][0]*(A[3][2]*A[4][4] - A[3][4]*A[4][2]) - A[2][2]*(A[3][0]*A[4][4] - A[3][4]*A[4][0]) + A[2][4]*(A[3][0]*A[4][2] - A[3][2]*A[4][0])) +
					 A[1][2]*(A[2][0]*(A[3][1]*A[4][4] - A[3][4]*A[4][1]) - A[2][1]*(A[3][0]*A[4][4] - A[3][4]*A[4][0]) + A[2][4]*(A[3][0]*A[4][1] - A[3][1]*A[4][0])) -
					 A[1][4]*(A[2][0]*(A[3][1]*A[4][2] - A[3][2]*A[4][1]) - A[2][1]*(A[3][0]*A[4][2] - A[3][2]*A[4][0]) + A[2][2]*(A[3][0]*A[4][1] - A[3][1]*A[4][0]))) +

			A[0][4]*(A[1][0]*(A[2][1]*(A[3][2]*A[4][3] - A[3][3]*A[4][2]) - A[2][2]*(A[3][1]*A[4][3] - A[3][3]*A[4][1]) + A[2][3]*(A[3][1]*A[4][2] - A[3][2]*A[4][1])) -
					 A[1][1]*(A[2][0]*(A[3][2]*A[4][3] - A[3][3]*A[4][2]) - A[2][2]*(A[3][0]*A[4][3] - A[3][3]*A[4][0]) + A[2][3]*(A[3][0]*A[4][2] - A[3][2]*A[4][0])) +
					 A[1][2]*(A[2][0]*(A[3][1]*A[4][3] - A[3][3]*A[4][1]) - A[2][1]*(A[3][0]*A[4][3] - A[3][3]*A[4][0]) + A[2][3]*(A[3][0]*A[4][1] - A[3][1]*A[4][0])) -
					 A[1][3]*(A[2][0]*(A[3][1]*A[4][2] - A[3][2]*A[4][1]) - A[2][1]*(A[3][0]*A[4][2] - A[3][2]*A[4][0]) + A[2][2]*(A[3][0]*A[4][1] - A[3][1]*A[4][0])));
		for(i = 0; i <= 4; i++)
		{
			for(j = 0; j <= 4; j++)
			{
				d1 = det4(A, j, i);
				B[i][j] = d1*pow(-1, (i+j))/d;
			}
		}
	}
/***************************************************************************/
/*	нахождение минора	4на4		*/
/***************************************************************************/
double det4(
			double A[5][5],
			int i,
			int j
			 )
	{
		int i1, j1, c1, c2;
		double d, A1[4][4];
		c1 = 0;
		c2 = 0;
		for(i1 = 0; i1 <= 4; i1++)
		{
			if(i1 != i)
			{
				c2 = 0;
				for(j1 = 0; j1 <= 4; j1++)
				{
					if(j1 != j)
					{
						A1[c1][c2] = A[i1][j1];
						c2 = c2 + 1;
					}
				}
				c1 = c1 + 1;
			}
		}
		d = A1[0][0]*(A1[1][1]*(A1[2][2]*A1[3][3] - A1[2][3]*A1[3][2]) - A1[1][2]*(A1[2][1]*A1[3][3] - A1[2][3]*A1[3][1]) + A1[1][3]*(A1[2][1]*A1[3][2] - A1[2][2]*A1[3][1])) -
			A1[0][1]*(A1[1][0]*(A1[2][2]*A1[3][3] - A1[2][3]*A1[3][2]) - A1[1][2]*(A1[2][0]*A1[3][3] - A1[2][3]*A1[3][0]) + A1[1][3]*(A1[2][0]*A1[3][2] - A1[2][2]*A1[3][0])) +
			A1[0][2]*(A1[1][0]*(A1[2][1]*A1[3][3] - A1[2][3]*A1[3][1]) - A1[1][1]*(A1[2][0]*A1[3][3] - A1[2][3]*A1[3][0]) + A1[1][3]*(A1[2][0]*A1[3][1] - A1[2][1]*A1[3][0])) -
			A1[0][3]*(A1[1][0]*(A1[2][1]*A1[3][2] - A1[2][2]*A1[3][1]) - A1[1][1]*(A1[2][0]*A1[3][2] - A1[2][2]*A1[3][0]) + A1[1][2]*(A1[2][0]*A1[3][1] - A1[2][1]*A1[3][0]));
		return d;
	}
/***************************************************************************/
/* Произведение   двух матриц  5*5                                         */
/***************************************************************************/
void umnmama5(double a[5][5],double b[5][5],
             double ab[5][5])
{
 int i,j,l;
 double s;
 for (i=0;i<5;i++)
     {for (j=0;j<5;j++)
        {s = 0.0;
         for (l=0;l<5;l++)
           s = s + a[i][l] * b[l][j];
         ab[i][j] = s;
        }
     }
}

/***************************************************************************/
/* Транспонирование матрицы   4*4                                          */
/***************************************************************************/
void transma4(double a[4][4],
             double at[4][4])
{int i,j;
 for (i=0;i<4;i++)
    for (j=0;j<4;j++)
	   at[i][j]=a[j][i];
}

void KepvLap(
			 KU_OSKP ka,
			 double p[6]
			 )
{
	p[0] = (1 - ka.e*ka.e)*pow((MU*ka.tosk*ka.tosk/(4*PI*PI)),(1./3.));
	p[1] = ka.e*sin(ka.wpi);
	p[2] = ka.e*cos(ka.wpi);
	p[3] = ka.i;
	p[4] = ka.om;
	p[5] = ka.u;
}

void RkaVka_KA(
			KU_OSKP *ka,
			double Rka[3],
			double Vka[3]
			)
{
	double f, V, R, a, n[3], r[3], v[3], z[3], vu[3], x[3], b[3], p;
	double MU1;
	MU1=398600.44;
	R = modul(Rka);
	V = modul(Vka);
	avb(Rka, r);
	avb(Vka, v);
	a = R*MU1/(2*MU1 - R*V*V);
	ka->tosk = DVAPI*sqrt(a*a*a/MU1);
	vektumn(r, v, n);
	p = skalpr(n, n)/MU1;
	ka->e = sqrt(1 - p/a);
	f = acos((a - R - a*(ka->e)*(ka->e))/(R*(ka->e)));
	z[0] = 0;
	z[1] = 0;
	z[2] = 1;
	x[0] = 1;
	x[1] = 0;
	x[2] = 0;
	ka->i = ugol(n, z);
	vektumn(z, n, vu);
	ka->om = ugol(vu, x);
	if (vu[1] < 0)
		ka->om = DVAPI - ka->om;
	ka->u = ugol(vu, r);
	vektumn(vu, r, b);
	if (ugol(n, b) > PINADVA)
		ka->u = DVAPI - ka->u;
	if (ka->u > PINADVA && ka->u < DVAPI - PINADVA)
	{
		f = DVAPI - f;
	}
	ka->wpi = ka->u - f;
	if (ka->wpi < 0)
		ka->wpi = ka->wpi + DVAPI;
}

void KA_RkaVka2(
			KU_OSKP ka,
			double Rka[3],
			double Vka[3]
			)
{
	double E, f, teta, V, R, a;
	double const eps8i= 1e-8;

	f = ka.u - ka.wpi;
	if (f < 0)
	{
		f = f + DVAPI;
	}
	if(fabs(PI - f) <= eps8i)
		E = f;
	else
		E = 2.0*atan(tan(f/2.0)*sqrt((1 - ka.e)/(1 + ka.e)));
	a = pow(MU*pow((ka.tosk/DVAPI), 2.0), 1.0/3.0);
	R = a*(1 - ka.e*cos(E));
	Rka[0] = cos(ka.om)*cos(ka.u) - sin(ka.om)*sin(ka.u)*cos(ka.i);
	Rka[1] = cos(ka.u)*sin(ka.om) + cos(ka.om)*sin(ka.u)*cos(ka.i);
	Rka[2] = sin(ka.u)*sin(ka.i);
	Rka[0] = Rka[0]*R;
	Rka[1] = Rka[1]*R;
	Rka[2] = Rka[2]*R;
	teta = atan(ka.e*sin(E)/sqrt(1 - ka.e*ka.e));
	V = sqrt(MU*(2.0/R - 1/pow(MU*pow((ka.tosk/DVAPI), 2.0), 1.0/3.0)));
	Vka[0] = -cos(ka.om)*sin(ka.u-teta) - sin(ka.om)*cos(ka.u-teta)*cos(ka.i);
	Vka[1] = -sin(ka.u-teta)*sin(ka.om) + cos(ka.om)*cos(ka.u-teta)*cos(ka.i);
	Vka[2] = cos(ka.u-teta)*sin(ka.i);
	Vka[0] = Vka[0]*V;
	Vka[1] = Vka[1]*V;
	Vka[2] = Vka[2]*V;
}
/***************************************************************************/
/* Определение оскулирующих параметров по вектору Лапласа   	           */
/***************************************************************************/
void LapvKep(
			 KU_OSKP *ka,
			 double p[6]
			 )
{
	double e, T, omgpi;
	e = sqrt(pow(p[1], 2.0)+pow(p[2], 2.0));
	T = 2*PI*(p[0]/(1-e*e))*sqrt(p[0]/(MU*(1-e*e)));
	if(fabs(p[1]) > 1.0)
	 omgpi = PI - PINADVA * sign(p[1]);
	else{
      if ((p[1] >= 0.0) && (p[2] >= 0.0))
		  omgpi = asin(p[1]/e);
	  else{
           if (p[2] <= 0.0)
			omgpi = (PI - asin(p[1]/e));
           else
			omgpi = (2*PI + asin(p[1]/e));
	  }
	}
	ka->e = e;
	ka->tosk = T;
	ka->wpi = omgpi;
	ka->i = p[3];
	ka->om = p[4];
	ka->u = p[5];
}
/*--------------------------------------------------------
|                       SCOVM                            |
|          Алгоритм сравнения времен                     |
|   Проверяется истинность выражения t1 > t2.            |
|   В этом случае выходному параметру а присваивается    |
|   значение 1, в противном случае  -1.                  |
|   Если t1 = t2, то а=0.                                |
|                                                        |
|   Вход : t1, t2;                                       |
|          где t1.d - сутки; t1.s - секунды.             |
|              t2.d - сутки; t2.s - секунды.             |
|   Выход: a;                                            |
|                                                        |
|                                          10.06.2005    |
|-------------------------------------------------------*/
int SCOVM (KU_TimeDATA *t1,KU_TimeDATA *t2, int *a )
{

	/* 10.06.2005 */
     *a =  0;
	 if ( t1->d > t2->d )
	 {
		*a =  + 1;
        return 0;
	 }
     *a =  - 1;
	 if ( t1->d == t2->d )
	 {
		if (t1->s > t2->s )
		{
			*a =  + 1;
            return 0;
		}
	 }
     *a =  - 1;

	 return 0;
}
/*********************************** end SCOVM *******************************************/
void umv1(double a[3][3],double b[3], double c[3])
{
double f;
int i, k;
for(i = 0; i<3; i++)
	{f = 0;
		for(k = 0; k<3; k++)
		f += a[i][k]*b[k];
   c[i] = f;
}
}

double GetUm(double Sh,double D, double H,double Rka[3],double Sm)
{  double MATR[3][3],sfi,BN,RN[3],DR[3],RKAP[3],ums,mrka,RG[3],Rz,alf;
Rz=6371;
alf = 1/298.257223563;
	MATR[0][0] = -sin(Sh)*cos(D);
	MATR[0][1] = -sin(Sh)*sin(D);
	MATR[0][2] = cos(Sh);
	MATR[2][0] = cos(Sh)*cos(D);
	MATR[2][1] = cos(Sh)*sin(D);
	MATR[2][2] = sin(Sh);
	MATR[1][0] = sin(D);
	MATR[1][1] = -cos(D);
	MATR[1][2] = 0;
	sfi = sin(Sh);
	BN = sqrt(1.0 - alf*(2.0-alf)*sfi*sfi);
	RN[0] = (Rz/BN + H)*cos(Sh)*cos(D);
	RN[1] = (Rz/BN + H)*cos(Sh)*sin(D);
	RN[2] = (Rz*(1.0-alf)/BN + H)*sin(Sh);

	RG[0] = Rka[0]*cos(Sm)+Rka[1]*sin(Sm);
	RG[1] = -Rka[0]*sin(Sm)+Rka[1]*cos(Sm);
	RG[2] = Rka[2];

	 DR[0] = RG[0]-RN[0];
	 DR[1] = RG[1]-RN[1];
	 DR[2] = RG[2]-RN[2];
	 umv1(MATR, DR, RKAP);
	 mrka = sqrt(RKAP[0]*RKAP[0]+RKAP[1]*RKAP[1]+RKAP[2]*RKAP[2]);
	 ums = asin(RKAP[2]/mrka);
	 return ums;
}
