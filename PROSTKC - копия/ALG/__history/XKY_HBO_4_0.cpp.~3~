/***************************************************************************

                                XKY_HBO_4_0.c
                             -------------------
 
 ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdarg.h>
#include <math.h>

#include "XKY_HBO_5_0.h"
#include "XKY_HBO_4_0.h"

extern double TKOC[];
extern double MKC[];

/*--------------------------------------------------------
|                       UGOLM                            |
|         Нахождение угла в интеpвале   (0,2П)           |
|                                                        |
|   Вход : x,y                                           |
|                                                        |
|   Выход: al                                            |
|                                                        |
|   Используются константы :                             |
|               KP     = 1.0e-14             TKOC[20]    |
|               DVAPI  = 6.283185307179586   TKOC[11]    |
|                                                        |
|   Используются процедуры : fsign()                     |
|                                          10.11.2004    |
|-------------------------------------------------------*/
int UGOLM(double x,double y,double *al)	
{
	 double s,b,a;

     s = FSIGN(x);
	 b = fabs(x);
	 if (b>1.0)  *al = (TKOC[11]/4.0) * s;
	 else
	 {
		a = (1.0-b > TKOC[20]) ? asin(x) : (TKOC[11]/4.0)*s;
		if (y<0)   *al = TKOC[11]/2.0 - a;
		else  *al = (b >= TKOC[20])? a + TKOC[11]/2.0 - (TKOC[11]/2.0) * s : 0.0;
	 }
	 return 0;
}
/***************************** end UGOLM *************************************************/


/***********************************************************************/
/*        (KORIN_E) Определение знакоположительных интервалов          */
/*                             значений функции                        */
/***********************************************************************/
/*                                                                     */
/*   вход:                                                             */
/*        t_begin - начало интервала анализа;                          */
/*        t_end   - конец интервала анализа;                           */
/*        а       - структура входных параметров функции;              */
/*   выход:                                                            */
/*         N        - число интервалов положительности функции         */
/*         MI[5][2] - массив интервалов положительности функции        */
/*                                                                     */   
/***********************************************************************/
/*   используются процедуры: KORXB_E()                                 */      
/***********************************************************************/
/*                                                                     */
/*   промежуточные величины:                                           */    
/*         i,i1  - индекс в массиве корней                             */ 
/*         j     - индекс в массиве интервалов                         */
/*                                                                     */
/***********************************************************************/
void KORIN_E(KU_TimeDATA t_begin,
			 KU_TimeDATA t_end,
			 Finp_E a,
			 double (*prcd)(Finp_E a),
			 int *N,
			 double MI[5][2])
{  
   int i,i1,j;

   int CR;
   double X[10];
   int IN;
   
   double time_begin = t_begin.d *86400. + t_begin.s;
   double time_end = t_end.d *86400. + t_end.s;

   memset(MI,0,sizeof(double) * 10);
  
   KORXB_E(t_begin,t_end,a,prcd,&CR,X,&IN);

   if(CR == 0)
   { 
	   if(IN == -1)    /*********** корней не найдено и вся ф-ция положительна ************/
	   {
		   MI[0][0] = time_begin;
           MI[0][1] = time_end;
		   *N = 1;
	   }else   *N = 0; /***** корней не найдено и вся ф-ция отрицательна или равна 0 ******/
	       
	   goto END;
	   
   }

   if(IN > 0)         /*** корней больше или равно 1 и на time_begin ф-ция отрицательна ***/
   {
	   i1 = 0;
	   j = -1;
   }else
   {
	   MI[0][0] = time_begin; /****** заполнение нулевой строки в массиве интервалов ******/
	   MI[0][1] = X[0];
	   i1 = 1;
	   j = 0;
   }

   for (i = i1; i <= CR - 1; i += 2)
   {
	   if( X[0] == time_end) goto M;
       j += 1;
	   MI[j][0] = X[i];      /******* заполнение остальных строк массива интервалов *******/ 
	   if( i == CR - 1 )
	   {
		   MI[j][1] = time_end;
		   goto M;
	   }
	   MI[j][1] = X[i + 1];
   }
          
M: *N = j + 1;
END: ;
}
/************************************** end KORIN_E ****************************************/

/********************************************************************/
/*		             (KORXB_E) Определение корней функции           */ 
/*		                                                            */
/*		Вычисляет корни ф-ции общего вида на заданном               */
/*		интервале методом хорд. Ф-ция задается в виде               */
/*		параметра prcd(a,F) a - аргумент; F - функция               */
/*		(процедуры вычтсления ее значнений)                         */
/********************************************************************/
/*   вход:                                                          */
/*      t_begin - начало интервала анализа;                         */
/*      t_end   - конец интервала анализа;                          */
/*      а       - структура входных параметров функции;             */
/*                                                                  */
/*   выход:                                                         */ 
/*      CR      - найденное число корнй;                            */ 
/*      X[CR]   - массив найденных корней;                          */
/*      IN      - индекс знака функции в начале интервала;          */
/*                                                                  */
/********************************************************************/
/*   константы:                                                     */
/*      tau_c   - шаг счёта при определении нач.усл. для метода хорд*/
/*      del_tau - точность по интервалу времени,на которое отстоят  */
/*                два соседних решения по методу хорд;              */
/*      del_f   - точность определения значений функции;            */           
/********************************************************************/
/*   промежуточные величины:                                        */
/*                                                                  */
/*       t1      - левый конец отрезка(интервала), точка "а";       */
/*       t2      - правый конец отрезка(интервала), точка "в";      */
/*       t3      - прмежуточное решение по методу хорд,точка "с";   */
/*       f1      - значение функции в точке "а";                    */
/*       f2      - значение функции в точке "в";                    */ 
/*       f3      - значение функции в точке "с";                    */
/********************************************************************/
void KORXB_E(KU_TimeDATA t_begin,KU_TimeDATA t_end,Finp_E a,double (*prcd)(Finp_E a),
		     int *CR,double X[10],int *IN) 
{
	double t,t1,t2,t3,t5,t6, f1,f2,f3,tau_c1;
	double tau_c,del_tau,del_f;
	int IN1,IN2; 

    double time_begin = t_begin.d *86400. + t_begin.s;
    double time_end = t_end.d *86400. + t_end.s;
  
    tau_c = TKOC[64];
	del_tau = TKOC[65];
	del_f = TKOC[66];

    memset(X,0,sizeof(double) * 10);
	
/************* 	уход от значения f1=0 , случайно получаемого 
                              на время начала интервала поиска ********************/
    a.t.d = t_begin.d;
    a.t.s = t_begin.s;

	
M:	f1 = (*prcd)(a);
	
	if(f1 == 0)
	{
		t1 = 10.;
		time_begin -= t1;
        
		a.t.d = (int)(time_begin / 86400);
		a.t.s = time_begin - a.t.d * 86400;

		goto M;
	}
/**********************************************************************************/	


	if(f1 > 0) *IN = -1; else *IN = 1;
	
	IN1 = - *IN;
	*CR = 0;
	t2 = time_begin;
	t5 = time_end + tau_c;
	goto M2;
	
M3: a.t.d = (int)(t2 / 86400);
	a.t.s = t2 - a.t.d * 86400; 
	f1 = (*prcd)(a);


/****************** нахождение начальных значений для 
                                 запуска метода хорд ******************************/ 	
M2: t2 += tau_c;

///////////////////////////
	printf("t2 = %6f\n",t2);
///////////////////////////

	if(t2 > t5) goto END;

    a.t.d = (int)(t2 / 86400);
	a.t.s = t2 - a.t.d * 86400; 
	f2 = (*prcd)(a);

	if((f1*f2) <= 0)
	{
		(*CR) ++;
		if(*CR > 10) goto M7;
		t1 = t2 -tau_c;
		if(f1 < 0) IN2 = +1; else IN2 = -1;
		if((IN2 * IN1) > 0) goto M8;
		IN1 = IN2;
		goto M1;
	}

	f1 = f2;
	goto M2;
/**********************************************************************************/
	
/**************** нахождение очередной точки(точки "с") для
                              вычисления значения функции *************************/
M1:
	t6 = t2 - t1;
	t = -( t6 / ( f2 - f1 ) ) * f1;
	t3 = t1 + t;
/**********************************************************************************/
	a.t.d = (int)(t3 / 86400);
	a.t.s = t3 - a.t.d * 86400; 
	f3 = (*prcd)(a); /**  вычисление очередного приближённого значения функции  **/
	if(fabs(f3) < del_f || fabs(t6) < del_tau) goto M4;


/****** формирование начальных условий для очередной итерации в методе хорд *******/	
	if( ( f1 * f3 ) < 0)
	{
		t2 = t3;
		f2 = f3;
	}else
	{
		t1 = t3;
		f1 = f3;
	}
	goto M1;

/***********************************************************************************/
	
M4:
	
	if(t3 > time_end)
	{
		(*CR)--;
		goto END;
	}else X[*CR - 1] = t3;    /*** запись в массив значения найденного корня ***/

//////////////////////////
  	printf("x = %6f\n",t3);
//////////////////////////
	
	tau_c1 = tau_c * 0.1;
	t2 = t3 + tau_c1;
	goto M3;
	
M7:
	printf("Необходимо увеличить число корней");
M8:
	printf("Ошибка в нахождении корня");
END: ;
}
/********************************** end KORXB_E ************************************/

/********************************************************************/
/*		        (KORXB_Ed) Определение корней функции на            */
/*         интервале, задаваемом вещественными числами              */   
/*		                                                            */
/*		Вычисляет корни ф-ции общего вида на заданном               */
/*		интервале методом хорд. Ф-ция задается в виде               */
/*		параметра prcd(a,F) a - аргумент; F - функция               */
/*		(процедуры вычтсления ее значнений)                         */
/********************************************************************/
/*   вход:                                                          */
/*      begin - начало интервала анализа;                           */
/*      end   - конец интервала анализа;                            */
/*      а     - структура входных параметров функции;               */
/*                                                                  */
/*   выход:                                                         */ 
/*      CR      - найденное число корнй;                            */ 
/*      X[CR]   - массив найденных корней;                          */
/*      IN      - индекс знака функции в начале интервала;          */
/*                                                                  */
/********************************************************************/
/*   константы:                                                     */
/*      tau_c   - шаг счёта при определении нач.усл. для метода хорд*/
/*      del_tau - точность по интервалу аргумента,на которое отстоят*/
/*                два соседних решения по методу хорд;              */
/*      del_f   - точность определения значений функции;            */           
/********************************************************************/
/*   промежуточные величины:                                        */
/*                                                                  */
/*       t1      - левый конец отрезка(интервала), точка "а";       */
/*       t2      - правый конец отрезка(интервала), точка "в";      */
/*       t3      - прмежуточное решение по методу хорд,точка "с";   */
/*       f1      - значение функции в точке "а";                    */
/*       f2      - значение функции в точке "в";                    */ 
/*       f3      - значение функции в точке "с";                    */
/*                                                     27.06.2007   */ 
/********************************************************************/
void KORXB_Ed(double begin, double end, Finp_E a, double (*prcd)(Finp_E a),
		      int *CR, double X[10], int *IN) 

{
	double t,t1,t2,t3,t5,t6, f1,f2,f3,tau_c1;
	double tau_c,del_tau,del_f;
	int IN1,IN2; 

    tau_c = TKOC[84];
	del_tau = TKOC[85];
	del_f = TKOC[86];

    memset(X,0,sizeof(double) * 10);
	
/************* 	уход от значения f1=0 , случайно получаемого 
                              на время начала интервала поиска ********************/
    a.fi = begin;
   	
M:	f1 = (*prcd)(a);
	
	if(f1 == 0)
	{
		t1 = 0.002908882;    // 10 угловых минут            
		begin -= t1;
        
		a.fi = begin;
	
		goto M;
	}
/**********************************************************************************/	


	if(f1 > 0) *IN = -1; else *IN = 1;
	
	IN1 = - *IN;
	*CR = 0;
	t2 = begin;
	t5 = end + tau_c;
	goto M2;
	
M3: a.fi = t2;
	f1 = (*prcd)(a);


/****************** нахождение начальных значений для 
                                 запуска метода хорд ******************************/ 	
M2: t2 += tau_c;

///////////////////////////
	printf("t2 = %6f\n",t2);
///////////////////////////

	if(t2 > t5) goto END;

    a.fi = t2;	
	f2 = (*prcd)(a);

	if((f1*f2) <= 0)
	{
		(*CR) ++;
		if(*CR > 10) goto M7;
		t1 = t2 -tau_c;
		if(f1 < 0) IN2 = +1; else IN2 = -1;
		if((IN2 * IN1) > 0) goto M8;
		IN1 = IN2;
		goto M1;
	}

	f1 = f2;
	goto M2;
/**********************************************************************************/
	
/**************** нахождение очередной точки(точки "с") для
                              вычисления значения функции *************************/
M1:
	t6 = t2 - t1;
	t = -( t6 / ( f2 - f1 ) ) * f1;
	t3 = t1 + t;
/**********************************************************************************/
	a.fi = t3;
	f3 = (*prcd)(a); /**  вычисление очередного приближённого значения функции  **/
	if(fabs(f3) < del_f || fabs(t6) < del_tau) goto M4;


/****** формирование начальных условий для очередной итерации в методе хорд *******/	
	if( ( f1 * f3 ) < 0)
	{
		t2 = t3;
		f2 = f3;
	}else
	{
		t1 = t3;
		f1 = f3;
	}
	goto M1;

/***********************************************************************************/
	
M4:
	
	if(t3 > end)
	{
		(*CR)--;
		goto END;
	}else X[*CR - 1] = t3;    /*** запись в массив значения найденного корня ***/

//////////////////////////
  	printf("x = %6f\n",t3);
//////////////////////////
	
	tau_c1 = tau_c * 0.1;
	t2 = t3 + tau_c1;
	goto M3;
	
M7:
	printf("Необходимо увеличить число корней");
M8:
	printf("Ошибка в нахождении корня");
END: ;
}
/********************************** end KORXB_Ed ************************************/

/***********************************************************************/
/*        (KORIN_Ed) Определение знакоположительных интервалов         */
/*        значений функции, задаваемой на вещественном интервале       */
/***********************************************************************/
/*                                                                     */
/*   вход:                                                             */
/*        begin - начало интервала анализа;                            */
/*        end   - конец интервала анализа;                             */
/*        а       - структура входных параметров функции;              */
/*   выход:                                                            */
/*         N        - число интервалов положительности функции         */
/*         MI[5][2] - массив интервалов положительности функции        */
/*                                                                     */   
/***********************************************************************/
/*   используются процедуры: KORXB_Ed()                                */      
/***********************************************************************/
/*                                                                     */
/*   промежуточные величины:                                           */    
/*         i,i1  - индекс в массиве корней                             */ 
/*         j     - индекс в массиве интервалов                         */
/*                                                      27.06.2007     */
/***********************************************************************/
void KORIN_Ed(double begin, double end, Finp_E a, double (*prcd)(Finp_E a),
			  int *N, double MI[5][2])
{  
   int i,i1,j;
   int CR;
   double X[10];
   int IN;
   

   memset(MI,0,sizeof(double) * 10);
  
   KORXB_Ed(begin,end,a,prcd,&CR,X,&IN);

   if(CR == 0)
   { 
	   if(IN == -1)    /*********** корней не найдено и вся ф-ция положительна ************/
	   {
		   MI[0][0] = begin;
           MI[0][1] = end;
		   *N = 1;
	   }else   *N = 0; /***** корней не найдено и вся ф-ция отрицательна или равна 0 ******/
	       
	   goto END;
	   
   }

   if(IN > 0)         /*** корней больше или равно 1 и на time_begin ф-ция отрицательна ***/
   {
	   i1 = 0;
	   j = -1;
   }else
   {
	   MI[0][0] = begin; /****** заполнение нулевой строки в массиве интервалов ******/
	   MI[0][1] = X[0];
	   i1 = 1;
	   j = 0;
   }

   for (i = i1; i <= CR - 1; i += 2)
   {
	   if( X[0] == end) goto M;
       j += 1;
	   MI[j][0] = X[i];      /******* заполнение остальных строк массива интервалов *******/ 
	   if( i == CR - 1 )
	   {
		   MI[j][1] = end;
		   goto M;
	   }
	   MI[j][1] = X[i + 1];
   }
          
M: *N = j + 1;

END: ;

}
/************************************** end KORIN_Ed ****************************************/

/*******************************************************/
/*                       Y2X                           */
/*     Решение системы двух линейных уравнений         */
/*                с двумя неизвестными                 */
/*                                                     */
/*   Вход:  а[2][2] - основная матрица системы         */
/*          b[2]    - столбец свободных членов         */
/*                                                     */
/*   Выход: х[2]    - столбец неизвестных              */
/*                                                     */
/*   Функция возвращает:                               */
/*          1, если система имеет единственное решение;*/
/*          0, если система не имеет решений или       */
/*             имеет бесконечное множество решений;    */
/*                                                     */ 
/*                                          23.01.08   */
/*******************************************************/      
int Y2X(double a[2][2], double b[2], double x[2])
{
	double det, det_x, det_y;

	det = a[0][0] * a[1][1] - a[1][0] * a[0][1];
	det_x = b[0] * a[1][1] - b[1] * a[0][1];
	det_y = a[0][0] * b[1] - a[1][0] * b[0];

	if (fabs (det) > TKOC[36]) 
	{
		x[0] = det_x / det;
		x[1] = det_y / det;

		return (1);
	}
	else  return (0);    
}
/************************************* end Y2X *******************************************/

/*******************************************************/
/*                       Y3X                           */
/*     Решение системы трех линейных уравнений         */
/*      с тремя неизвестными (матричный метод)         */
/*                                                     */
/*   Вход:  а[3][3] - основная матрица системы         */
/*          b[3]    - столбец свободных членов         */
/*                                                     */
/*   Выход: х[3]    - столбец неизвестных              */
/*                                                     */
/*   Функция возвращает:                               */
/*          1, если система имеет единственное решение;*/
/*          0, если система не имеет решений или       */
/*             имеет бесконечное множество решений;    */
/*                                                     */ 
/*                                          23.01.08   */
/*******************************************************/      
int Y3X(double a[3][3], double b[3], double x[3])
{
	double det;

	det = DET_3(a);

	if (fabs (det) > TKOC[36]) 
	{
        OMATR3(a);
		YM_MV_3(a,b,x);

		return (1);
	}
	else  return (0);	
}
/************************************* end Y3X *******************************************/

/*******************************************************/
/*                       Y5X                           */
/*     Решение системы пяти линейных уравнений         */
/*      с пятью неизвестными (матричный метод)         */
/*                                                     */
/*   Вход:  а[5][5] - основная матрица системы         */
/*          b[5]    - столбец свободных членов         */
/*                                                     */
/*   Выход: х[5]    - столбец неизвестных              */
/*                                                     */
/*   Функция возвращает:                               */
/*          1, если система имеет единственное решение;*/
/*          0, если система не имеет решений или       */
/*             имеет бесконечное множество решений;    */
/*                                                     */ 
/*                                          23.01.08   */
/*******************************************************/      
int Y5X(double a[5][5], double b[5], double x[5])
{
	double det;
	double c[5][5];             
	int i,j;

   for (i = 0; i < 5; i++)
   {
		for (j = 0; j < 5; j++)
		{
			c[i][j] = a[i][j];
		}
   }                            

	det = DET_5(a);

	if (fabs (det) > TKOC[36]) 
	{
        OMATR5(a);

		YM_MV_5(a,b,x);

		return (1);
	}
	else  return (0);		
}
/************************************* end Y5X *******************************************/

/*-------------------------------------------------------
|                        YM_MV_6                        |
|            Умножение матpицы 6х6 на вектоp            |
|                                                       |
|  Вход:  а[6][6], b[6]                                 |
|                                                       |
|  Выход: c[6]  (отличен от b[])                        |
|                                                       |
|                                          30.06.04     |
|------------------------------------------------------*/
int YM_MV_6 (double a[][6], double b[6], double c[6])
{
	 double r;
	 int i, j;

	 for (i = 1; i <= 6; i++)
	 {
		r = 0.0e00;
		for (j = 1; j <= 6; j++)
		{
			r = r + a[i-1][j-1] * b[j-1];
		}
		c[i-1] = r;
	 }
	 return 0;
}
/************************************ end YM_MV_6 ****************************************/

/*-------------------------------------------------------
|                        YM_MV_3                        |
|            Умножение матpицы 3х3 на вектоp            |
|                                                       |
|  Вход:  а[3][3], b[3]                                 |
|                                                       |
|  Выход: c[3]  (отличен от b[])                        |
|                                                       |
|                                          30.06.04     |
|------------------------------------------------------*/
int YM_MV_3 (double a[][3], double b[3], double c[3])
{
	 double r;
	 int i,j;

	 for ( i = 1; i <= 3; i++)
	 {
		r = 0.0e00;
		for (j = 1; j <= 3; j++)
		{
			r = r + a[i-1][j-1] * b[j-1];
		}
		c[i-1] = r;
	 }
 	 return 0;
}
/******************************** end YM_MV_3 ********************************************/

/*-------------------------------------------------------
|                        YM_MM_6                        |
|            умножение матpицы 6х6 на матpицу 6х6       |
|                                                       |
|  Вход:   a[6][6], b[6][6]                             |
|                                                       |
|  Выход:  c[6][6]  ( отличен от a[6][6] и b[6][6] )    |
|                                                       |
|                                          30.06.04     |
|------------------------------------------------------*/
int YM_MM_6 (double a[][6], double b[][6], double c[][6])
{
	 int i, j, l;

	 for (i = 1; i <= 6; i++)
	 {
		for (j = 1; j <= 6; j++)
		{
			c[i-1][j-1] = 0.0e00;
			for (l = 1; l <= 6; l++)
			{
				c[i-1][j-1] = c[i-1][j-1] + a[i-1][l-1] * b[l-1][j-1];
			}
		}
	 }
	 return 0;
}
/********************************* end YM_MM_6 *******************************************/

/*-------------------------------------------------------
|                        YM_MM_3                        |
|            умножение матpицы 3х3 на матpицу 3х3       |
|                                                       |
|  Вход:   a[3][3], b[3][3]                             |
|                                                       |
|  Выход:  c[3][3]  ( отличен от a[3][3] и b[3][3] )    |
|                                                       |
|                                          30.06.04     |
|------------------------------------------------------*/
int YM_MM_3 (double a[][3], double b[][3], double c[][3])
{
	 int i, j, l;

	 for (i = 1; i <= 3; i++)
	 {
		for (j = 1; j <= 3; j++)
		{
			c[i-1][j-1] = 0.0e00;
			for (l = 1; l <= 3; l++)
			{
				c[i-1][j-1] = c[i-1][j-1] + a[i-1][l-1] * b[l-1][j-1];
			}
		}
	 }
	 return 0;
}
/******************************* end YM_MM_3 *********************************************/

/*---------------------------------------------------------------
| 	                        OMATR                               |
| 	 Программа предназначена для вычисления матрицы,            |
| 	 обpатной матpице A.                                        |
|                                                               |
|   A - исходная матрица  типа double pазмеpности 6х6.          | 
|   Обpатная матpица будет помещена на  место исходной матрицы. |
|   eps_OMATR - точность вычисления элементов обратной матpицы. |
|   (задана константой в const_2005.h)                          |
|                                                               |
|   Если в процессе обращения матрицы какой-либо главный        |  
|   элемент окажется  меньше eps_OMATR, то выполнение программы |
|   прервется и возвpащаемое значение будет pавно 1.            |
|                                                               | 
|   Обращение   матрицы  производится  по  методу               |        
|   Гаусса-Жордана с выбором на каждом шаге в качестве          |   
|   главного элемента максимального элемента в еще              | 
|   непреобразованной части матрицы.                            |                       
|   Вспомагательная функция PERM_OMATR используется для         | 
|   пеpестановки элементов матpицы.                             |
|                                                               |
|   Используются константы :                                    |
|               eps_OMATR     = 1.0e-12    TKOC[36]             |
|                                                               |                                 
|   Вход : A[6][6]       -  матрица  рамерности 6*6             |
|                                                               |
|   Выход: A[6][6]       -  матрица  рамерности 6*6             |
|                                                               |
|   Используются процедуры :  PERM_OMATR                        |
|                             fabs                              |
|                                                 04.10.2005    |
|--------------------------------------------------------------*/
int OMATR( double  a[6][6])
{
	 double pv ;
	 int i, j, ii, k, pi, pj, ri, ci, rk, r[6], c[6], js;

	 for (i = 1; i <= 6; i++)
     {
		r [i-1] = i;
		c [i-1] = i;
	 }
	 pi = 1;
	 pj = 1;
	 for (i = 1; i <= 6; i++)
	 {
		for (j = 1; j <= 6; j++)
		{
			if ( fabs ( a [i-1][j-1] ) > fabs ( a [pi-1][pj-1] ))
			{
				pi = i;
				pj = j;
			}
		}
	 }
	 for ( i = 1; i <= 6; i++)
	 {
		ri = r [pi -1];
		r [pi -1] = r [i -1];
		r [i-1] = ri;
		ci = c [pj-1];
		c [pj-1] = c [i-1];
		c [i-1] = ci;
		if (TKOC[36] > fabs ( a [ri -1][ci - 1] ))
		{
			for (ii = 1; ii <= 6; ii++)
			{
				for ( j = 1; j <= 6; j++)
				{
					a [ii -1][j-1] = (double) 0.0;
					printf ("   ГЛАВНЫЙ ЭЛЕМЕНТ МЕНЬШЕ EPS \n ");
					return 1;
				}
			}
		}
		for ( j =1; j <= 6; j++)
		{
			if ( j != i)
			{
				js = c [j-1];
				a [ri-1][js-1] = a [ri-1][js-1] / a [ri-1][ci-1];
			}
		}
		a [ri-1][ci-1] = (double)1.0 / a [ri-1][ci-1];
		pv = (double) 0.0;
		for ( k =1; k <= 6; k++)
		{
			if (k != i)
			{
				rk = r [k-1];
				for  ( j = 1; j <= 6; j++)
				{
					if ( j != i)
					{
						js = c [j-1];
						a [rk-1][js-1] = a [rk-1][js-1] -
										a [ri-1][js-1] * a [rk-1][ci-1];
						if (k > i)
						{
							if (j > i)
							{
								if (fabs ( a [rk-1][js-1]) >= fabs (pv-1));
								{
									pi = k;
									pj = j;
									js = c [j-1];
									pv = a [rk-1][js-1];
								}
							}
						}
					}
				}
				a [rk-1][ci-1] = - a [ri-1][ci-1] * a [rk-1][ci-1];
			}
		}
	 } // end for ( i = 1; i <= 6; i++) 

	  PERM_OMATR (a, r, c, 1);
	  PERM_OMATR (a, c, r, 2);

	return 0;
}
/*********************************** end OMATR *******************************************/

/*--------------------------------------------------------
|                        FSIGN                           |
|              Нахождение знака числа                    |
|                                                        |
|                                          15.10.01      |
|--------------------------------------------------------*/
int FSIGN(double x)
{
      if(x>0.)	                      return(1);
	  if(x<0.)                        return(-1);
	  else
	                                  return(0);
}
/******************************* end FSIGN ***********************************************/

/*----------------------------------------------------------
| функция одного  аpгумента,  аналог  функции  ARCCOS.     |
| Отличается от ARCCOS pасшиpенной областью опpеделения.   |
-----------------------------------------------------------*/
double arccs(double x /* значение косинуса угла */)
{
	if((x > -1.0) && (x < 1.0)) return (acos(x));
    else if(x >= 1.0)  return(0.0);
         else   return(TKOC[1]);
}
/******************************************************************************************/

/*----------------------------------------------------------
| функция одного  аpгумента,  аналог  функции  ARCSIN.     |
| Отличается от ARCSIN pасшиpенной областью опpеделения.   |
-----------------------------------------------------------*/
double arcsn(double x /* значение синуса угла */ )
{
 if((x > -1.0) && (x < 1.0))  return(asin(x));
 else if(x >= 1.0)  return(TKOC[1]/2.0);
      else   return(-TKOC[1]/2.0);
}
/******************************************************************************************/

/****************************************************/
/*	                  YM_MV_5                       */
/*	        Умножение матpицы 5х5 на вектоp 5x1     */
/*	                                                */
/*	  Вход:  а[5][5], b[5]                          */
/*	                                                */
/*	  Выход: c[5]                                   */
/*	                                                */
/*	                                     04.12.07   */
/****************************************************/
int YM_MV_5 (double a[5][5], double b[5], double c[5])
{
	int i, j;

	for (i = 0; i < 5; i++)
	 {
		c[i] = 0.0;

		for (j = 0; j < 5; j++)
		{
			c[i] = c[i] + a[i][j] * b[j];
		}
	 }

	 return 0;
} 
/********************************* end YM_MV_5 ***********************************/

/*****************************************************/
/*                       DET_3                       */
/*     Вычисление определителя третьего порядка      */
/*                                                   */
/*    Вход: а[3][3]                                  */
/*                                                   */
/*    Функция возвращает значение определителя       */
/*                                                   */
/*                                        14.12.07   */
/*****************************************************/  
double DET_3(double a[3][3])
{
	double det;

	det =  a[0][0] * (a[1][1] * a[2][2] - a[1][2] * a[2][1]) -
		   a[0][1] * (a[1][0] * a[2][2] - a[2][0] * a[1][2]) + 
		   a[0][2] * (a[1][0] * a[2][1] - a[1][1] * a[2][0]);
		  
	return(det);
}
/************************************ end DET_3 *****************************************/

/*****************************************************/
/*                       DET_4                       */
/*     Вычисление определителя четвертого порядка    */
/*                                                   */
/*    Определитель матрицы равен сумме произведений  */ 
/*    элементов нулевой строки матрицы а[4][4] на    */
/*    их алгебраические дополнения                   */
/*                                                   */ 
/*    Вход: а[4][4] - матрица четвертого порядка     */
/*                                                   */
/*    Функция возвращает значение определителя       */
/*                                                   */
/*    Используются процедуры :  DET_3                */
/*                                                   */
/*                                        14.12.07   */
/*****************************************************/  
double DET_4(double a[4][4])
{
	double det;
	double b[3][3],d[4];
	int ii, jj, j;

	det = 0.0;

	for(j = 0; j < 4; j++)                 // цикл по элементам нулевой строки
	{
	   for(ii = 1; ii < 4; ii++)
			for(jj = 0; jj < 4; jj++)
			{
				if(jj < j) b[ii - 1][jj] = a[ii][jj];
				if(jj > j) b[ii - 1][jj - 1] = a[ii][jj];
			}

       d[j] = DET_3(b);
	   det = det + pow(-1.0,j + 2) * a[0][j] * d[j];
	}

	return(det);
}
/************************************ end DET_4 *****************************************/

/*****************************************************/
/*                       DET_5                       */
/*     Вычисление определителя пятого порядка        */
/*                                                   */
/*    Определитель матрицы равен сумме произведений  */ 
/*    элементов нулевой строки матрицы а[5][5] на    */
/*    их алгебраические дополнения                   */
/*                                                   */
/*    Вход: а[5][5] - матрица пятого порядка         */
/*                                                   */
/*    Функция возвращает значение определителя       */
/*                                                   */
/*    Используются процедуры :  DET_4                */
/*                                                   */
/*                                        20.12.07   */
/*****************************************************/  
double DET_5(double a[5][5])
{
 	double det;
	double b[4][4],d[5];
	int ii, jj, j;

	det = 0.0;

	for(j = 0; j < 5; j++)                 // цикл по элементам нулевой строки
	{
	   for(ii = 1; ii < 5; ii++)
			for(jj = 0; jj < 5; jj++)
			{
				if(jj < j) b[ii - 1][jj] = a[ii][jj];
				if(jj > j) b[ii - 1][jj - 1] = a[ii][jj];
			}

       d[j] = DET_4(b);                        
	   det = det + pow(-1.0,j + 2) * a[0][j] * d[j];
	}

	return(det);
}
/*************************************** end DET_5 ***************************************/

/*********************************************************/
/*                       MINOR_2                         */
/*     Программа вычисления минора второго порядка       */
/*                                                       */
/*  По заданным номерам строки и столбца элемента данной */
/*  матрицы программа вычисляет соответствующий минор    */
/*  второго порядка                                      */
/*                                                       */
/*  Вход:  i, j - индексы элемента, для которого         */
/*                вычисляется минор                      */
/*         a[3][3] - матрица пятого порядка              */
/*                                                       */ 
/*  Функция возвращает значение вычисленного минора      */
/*                                                       */
/*  Используются процедуры :  DET_2                      */
/*                                         23.01.08      */
/*********************************************************/     
double MINOR_2(int i, int j, double a[3][3])
{
   int ii, jj;
   double M[2][2];
   double det;

   for(ii = 0; ii < 3; ii++)
   {
	   if(ii != i)
		   for(jj = 0; jj < 3; jj++)
		   {
			   if(ii < i && jj < j) M[ii][jj] = a[ii][jj];
               if(ii < i && jj > j) M[ii][jj - 1] = a[ii][jj];
			   if(ii > i && jj < j) M[ii - 1][jj] = a[ii][jj];
			   if(ii > i && jj > j) M[ii - 1][jj - 1] = a[ii][jj];
		   }
   }

   det = M[0][0] * M[1][1] - M[0][1] * M[1][0];
   return(det);
}
/********************************** end MINOR_2 *****************************************/

/*********************************************************/
/*                       MINOR_4                         */
/*     Программа вычисления минора четвертого порядка    */
/*                                                       */
/*  По заданным номерам строки и столбца элемента данной */
/*  матрицы программа вычисляет соответствующий минор    */
/*  четвертого порядка                                   */
/*                                                       */
/*  Вход:  i, j - индексы элемента, для которого         */
/*                вычисляется минор                      */
/*         a[5][5] - матрица пятого порядка              */
/*                                                       */ 
/*  Функция возвращает значение вычисленного минора      */
/*                                                       */
/*  Используются процедуры :  DET_4                      */
/*                                         09.01.08      */
/*********************************************************/     
double MINOR_4(int i, int j, double a[5][5])
{
   int ii, jj;
   double M[4][4];
   double det;

   for(ii = 0; ii < 5; ii++)
   {
	   if(ii != i)
		   for(jj = 0; jj < 5; jj++)
		   {
			   if(ii < i && jj < j) M[ii][jj] = a[ii][jj];
               if(ii < i && jj > j) M[ii][jj - 1] = a[ii][jj];
			   if(ii > i && jj < j) M[ii - 1][jj] = a[ii][jj];
			   if(ii > i && jj > j) M[ii - 1][jj - 1] = a[ii][jj];
		   }
   }

   det = DET_4(M);

   return(det);
}
/********************************** end MINOR_4 *****************************************/

/**********************************************************/
/*                        OMATR3                          */
/* Программа вычисления обpатной матpицы третьего порядка */
/*                                                        */
/* 	Обращение матрицы производится c помощью вычисления   */        
/*  алгебраических дополнений элементов данной матрицы    */    
/*                                                        */
/*  Вход : a[3][3]       -  матрица  рамерности 3*3       */
/*                                                        */
/*  Выход: a[3][3]       -  матрица  рамерности 3*3       */
/*                                                        */
/*  Используются процедуры :  DET_3, MINOR_2              */
/*                                                        */
/*                                            23.01.08    */       
/**********************************************************/         
int OMATR3( double  a[3][3])
{
  double AD[3][3];
  double det,M;
  int i,j;

  det = DET_3(a);

  if (TKOC[36] > fabs (det))  printf ("   Матрица необратима \n ");   

  for(i = 0; i < 3; i++)
  {
	  for(j = 0; j < 3; j++)
	  {
         M = MINOR_2(i,j,a);
		 AD[j][i] = pow(-1, i+j+2) * M; 
	  }
  }

  for(i = 0; i < 3; i++)
  {
	  for(j = 0; j < 3; j++) a[i][j] = AD[i][j] / det;
	  
  }

  return(1);
}
/*********************************** end OMATR3 *******************************************/

/**********************************************************/
/*                        OMATR5                          */
/*  Программа вычисления обpатной матpицы пятого порядка  */
/*                                                        */
/* 	Обращение матрицы производится c помощью вычисления   */        
/*  алгебраических дополнений элементов данной матрицы    */    
/*                                                        */
/*  Вход : a[5][5]       -  матрица  рамерности 5*5       */
/*                                                        */
/*  Выход: a[5][5]       -  матрица  рамерности 5*5       */
/*                                                        */
/*  Используются процедуры :  DET_5, MINOR_4              */
/*                                                        */
/*                                            09.01.08    */       
/**********************************************************/         
int OMATR5( double  a[5][5])
{
  double AD[5][5];
  double det,M;
  int i,j;

  det = DET_5(a);

  if (TKOC[36] > fabs (det))  printf ("   Матрица необратима \n ");    

  for(i = 0; i < 5; i++)
  {
	  for(j = 0; j < 5; j++)
	  {
         M = MINOR_4(i,j,a);
		 AD[i][j] = pow(-1, i+j+2) * M;
	  }
  }

  for(i = 0; i < 5; i++)
  {
	  for(j = 0; j < 5; j++) a[i][j] = AD[j][i] / det;
  }

  return(1);
}
/*********************************** end OMATR5 *******************************************/

/*----------------------------------------------------------------
|                             PERM_OMATR                         |
|	    Вспомогательная процедура для OMATR                      |
|      для пеpестановки элементов матpицы    рамерности 6*6.     |
|	                                                             |
|	Вход	s[6]	- массив индексов строк                      |		
|	        d[6]	- массив индексов столбцов                   |
|		    priz	- признак обращения (1 - первое обращение,   | 
|								         2 - второе обращение)   |
|	       	A[6][6]			- матрица  размерности 6*6           |
|                                                                |
|	Выход	A[6][6]			- матрица  размерности 6*6           | 
|	                                                             |
|                                                 04.10.2005     |
----------------------------------------------------------------*/
int  PERM_OMATR( double a[6][6], int s[6], int d[6], int priz)
{
 double w;
 int  i, p, ta [6], l [6], t, j, k, js;

 for ( i = 1; i <= 6; i++)
 {
	ta [i-1] = i;
	l [i-1] = i;
 }
 for ( i =1; i <= 6; i++)
 {
	t = s [i-1];
	j = l [t-1];
	k = d [i-1];
	if ( j != k)
	{
		if ( priz == 2 )
		{
			for ( p = 1; p <= 6; p++)
			{
  				w = a [p-1][j-1];
				a [p-1][j-1] = a [p-1][k-1];
				a [p-1][k-1] = w;
			}
		}
		else
		{
			for ( p = 1; p <= 6; p++)
			{
				w = a [j-1][p-1];
				a [j-1][p-1] = a [k-1][p-1];
				a [k-1][p-1] = w;
			}
		}
		ta [j-1] = ta [k-1];
		ta [k-1] = t;
		js = ta [j-1];
		l [t-1] = l [js-1];
		l [js-1] = j;
	}  // end if ( j != k) 
 }//	end for ( i =1; i <= 6; i++) 
return 0;
}
/********************************* end PERM_OMATR *****************************************/


/***************************************************************************/
/* Транспонирование матрицы                                                */
/***************************************************************************/
void TRANSMA(double a[3][3],
             double at[3][3])
{
	int i,j;

	 for (i=0;i<3;i++)
		for (j=0;j<3;j++)  
			at[i][j]=a[j][i];
}
/***************************************************************************/
/* Скалярное произведение двух векторов                                    */
/***************************************************************************/
double SKALPR(double x[3],double y[3])
{ 
	return(x[0]*y[0] + x[1]*y[1] + x[2]*y[2]);
}
/***************************************************************************/
/* Линейная   комбинация  двух векторов                                    */
/***************************************************************************/
void LKOMB(double a,double va[3],double b,double vb[3],
           double c[3])
{ 
	int i;
  
	for (i=0;i<3;i++)  c[i] = a * va[i] + b * vb[i];
}
/****************************************************************************/
/* Векторное умножение                                                      */
/****************************************************************************/
void VEKTUMN(double v1[3],double v2[3],
             double v3[3])
{
 v3[0] = v1[1] * v2[2] - v1[2] * v2[1];
 v3[1] = v1[2] * v2[0] - v1[0] * v2[2];
 v3[2] = v1[0] * v2[1] - v1[1] * v2[0];
}
/****************************************************************************/
/* Заполнение матрицы значениями                                            */
/****************************************************************************/
void ZAPOLN(double m[3][3],double m00,double m01,double m02,
                           double m10,double m11,double m12,
                           double m20,double m21,double m22 )
{
	m[0][0]=m00;m[0][1]=m01;m[0][2]=m02;
	m[1][0]=m10;m[1][1]=m11;m[1][2]=m12;
	m[2][0]=m20;m[2][1]=m21;m[2][2]=m22;
}
/***************************************************************************/
/* Ноpмиpование вектоpа                                                    */
/***************************************************************************/
int NORMV(double x[3])      /*параметр возврата:1-вектор нормируется
						0-слишком маленький  */
{ 
	double m,eps1;
	int pv=1;

	//eps1= TKOC[18];
	eps1= 0.00000000001;

	m=MODUL(x);
	if (m > eps1)
	{
	     x[0]=x[0]/m; x[1]=x[1]/m; x[2]=x[2]/m;
	}
	else
	{
		pv=0;
		x[0]=0.0;x[1]=0;x[2]=0;
	}
	return (pv);
}
/******************************************************************/
/** Копирование матрицы********************************************/
/******************************************************************/
void maAvmaB(double A[][3],double B[][3])
{
	int i,j;

	for (i=0;i<3;i++)
		for (j=0;j<3;j++)
			B[i][j]=A[i][j];
}
/******************************************************************/
/** Копирование вектора********************************************/
/******************************************************************/
void AvB(double a[],double b[])
{
	int i;

	for (i=0;i<3;i++) b[i]=a[i];
}
/***************************************************************************/
/* норма вектора                                                           */
/***************************************************************************/
double MODUL(double xv[3])
{
	return(sqrt(xv[0]*xv[0] + xv[1]*xv[1] + xv[2]*xv[2]));
}           
/***************************************************************************/
